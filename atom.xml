<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lain&#39;s Blog</title>
  <subtitle>藏剑于身 待时而动</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://softlns.github.io/"/>
  <updated>2016-12-06T03:22:48.245Z</updated>
  <id>https://softlns.github.io/</id>
  
  <author>
    <name>Lain</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>s3fs使用指南</title>
    <link href="https://softlns.github.io/2016/12/06/s3fs-guide/"/>
    <id>https://softlns.github.io/2016/12/06/s3fs-guide/</id>
    <published>2016-12-06T03:20:12.000Z</published>
    <updated>2016-12-06T03:22:48.245Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>KS3（Kingsoft Standard Storage Service）服务是一个对象存储类服务。类似于网盘，可以通过网络随时随地的获取存储数据。金山云为用户管理KS3存储桶提供了两种控制管理方式：金山云的后台Consol、金山云官方KS3的SDK。</p>
<p>相比于以上两种使用场景，在实际的开发应用中，常常还有这样的场景：把KS3存储桶mount到本地文件系统，使得用户可以像操作文件目录一样操作KS3的对象。</p>
<p>本节所介绍的S3FS fuse，就是这么一款工具；针对linux操作系统，帮助用户把KS3的桶mount到本地文件系统，使得用户操作存储桶里的数据就如同操作本地文件一样方便。</p>
<a id="more"></a>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="依赖环境准备"><a href="#依赖环境准备" class="headerlink" title="依赖环境准备"></a>依赖环境准备</h3><h4 id="Ubuntu环境"><a href="#Ubuntu环境" class="headerlink" title="Ubuntu环境"></a>Ubuntu环境</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install automake autotools-dev g++ git libcurl4-gnutls-dev libfuse-dev libssl-dev libxml2-dev make pkg-config</div></pre></td></tr></table></figure>
<h4 id="CentOS环境"><a href="#CentOS环境" class="headerlink" title="CentOS环境"></a>CentOS环境</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo yum install automake fuse fuse-devel gcc-c++ git libcurl-devel libxml2-devel make openssl-devel</div></pre></td></tr></table></figure>
<h3 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h3><h4 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git <span class="built_in">clone</span> https://github.com/s3fs-fuse/s3fs-fuse.git</div></pre></td></tr></table></figure>
<h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> s3fs-fuse</div><div class="line">./autogen.sh</div><div class="line">./configure</div><div class="line">make</div><div class="line">sudo make install</div></pre></td></tr></table></figure>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="配置KS3秘钥"><a href="#配置KS3秘钥" class="headerlink" title="配置KS3秘钥"></a>配置KS3秘钥</h3><p>配置KS3的KS3ACCESSKEYID、KS3SECRETACCESSKEY信息，并将其存储在/etc/passwd-s3fs 文件中<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> KS3ACCESSKEYID:KS3SECRETACCESSKEY &gt; /etc/passwd<span class="_">-s</span>3fs</div></pre></td></tr></table></figure></p>
<p>修改秘钥文件权限，来限制访问：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chmod 640 /etc/passwd<span class="_">-s</span>3fs</div></pre></td></tr></table></figure></p>
<h3 id="挂载KS3存储桶"><a href="#挂载KS3存储桶" class="headerlink" title="挂载KS3存储桶"></a>挂载KS3存储桶</h3><p>将KS3 bucket 挂载到指定目录<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s3fs &lt;your-ks3-bucket-name&gt; &lt;your-mount-point&gt;  -o url=&lt;your-ks3-endpoint&gt;</div></pre></td></tr></table></figure></p>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p>将KS3北京region的 ks3-fs-test 存储桶挂载到本地 /mnt/ks3 目录下， Ks3AccesskeyId 是 sgyO124X+/ZRbmgrbP7d，Ks3SecretAccessKey 是  p9/6yLzbU2FZEPw5vCPf2/buQOz1SVNdqqBtzscH， ks3 endpoint是： <a href="http://ks3-cn-shanghai-internal.ksyun.com" target="_blank" rel="external">http://ks3-cn-shanghai-internal.ksyun.com</a> 。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> sgyO124X+/ZRbmgrbP7d:p9/6yLzbU2FZEPw5vCPf2/buQOz1SVNdqqBtzscH &gt; /etc/passwd<span class="_">-s</span>3fs</div><div class="line">chmod 640 /etc/passwd<span class="_">-s</span>3fs</div><div class="line">mkdir /mnt/ks3</div><div class="line">ossfs ks3-fs-test  /mnt/ks3 -o url=http://ks3-cn-shanghai-internal.ksyun.com</div></pre></td></tr></table></figure></p>
<h3 id="卸载bucket"><a href="#卸载bucket" class="headerlink" title="卸载bucket:"></a>卸载bucket:</h3><p>fusermount -u /mnt/s3fs</p>
<h3 id="功能支持"><a href="#功能支持" class="headerlink" title="功能支持"></a>功能支持</h3><table>
<thead>
<tr>
<th>文件操作</th>
<th>测试结果</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>mkdir</td>
<td>pass</td>
<td></td>
</tr>
<tr>
<td>listdir</td>
<td>pass</td>
<td></td>
</tr>
<tr>
<td>rmdir</td>
<td>pass</td>
<td></td>
</tr>
<tr>
<td>isfile</td>
<td>pass</td>
<td></td>
</tr>
<tr>
<td>isdir</td>
<td>pass</td>
<td></td>
</tr>
<tr>
<td>isabs</td>
<td>pass</td>
<td></td>
</tr>
<tr>
<td>exists</td>
<td>pass</td>
<td></td>
</tr>
<tr>
<td>makedirs</td>
<td>pass</td>
<td></td>
</tr>
<tr>
<td>stat</td>
<td>pass</td>
<td></td>
</tr>
<tr>
<td>getsize</td>
<td>pass</td>
<td></td>
</tr>
<tr>
<td>mknod</td>
<td>pass</td>
<td></td>
</tr>
<tr>
<td>open</td>
<td>pass</td>
<td></td>
</tr>
<tr>
<td>read</td>
<td>pass</td>
<td></td>
</tr>
<tr>
<td>readline</td>
<td>pass</td>
<td></td>
</tr>
<tr>
<td>readlines</td>
<td>pass</td>
<td></td>
</tr>
<tr>
<td>close</td>
<td>pass</td>
<td></td>
</tr>
<tr>
<td>flush</td>
<td>pass</td>
<td></td>
</tr>
<tr>
<td>fileno</td>
<td>pass</td>
<td></td>
</tr>
<tr>
<td>lell</td>
<td>pass</td>
<td></td>
</tr>
<tr>
<td>next</td>
<td>pass</td>
<td></td>
</tr>
<tr>
<td>seek</td>
<td>pass</td>
<td></td>
</tr>
<tr>
<td>truncate</td>
<td>pass</td>
<td></td>
</tr>
<tr>
<td>rename</td>
<td>pass</td>
<td></td>
</tr>
<tr>
<td>copyfile</td>
<td>pass</td>
<td></td>
</tr>
<tr>
<td>move</td>
<td>pass</td>
<td></td>
</tr>
<tr>
<td>remove</td>
<td>pass</td>
<td></td>
</tr>
<tr>
<td>rmdir</td>
<td>pass</td>
<td></td>
</tr>
<tr>
<td>copy</td>
<td>pass</td>
<td></td>
</tr>
<tr>
<td>copytree</td>
<td>pass</td>
<td></td>
</tr>
<tr>
<td>chmod</td>
<td>Filed</td>
</tr>
</tbody>
</table>
<h2 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h2><p>s3fs提供的功能和性能和本地文件系统相比，具有一些局限性。具体包括：</p>
<ul>
<li>随机或追加写文件会导致整个文件的重写。</li>
<li>元数据操作，例如list directory，性能较差，因为需要远程访问KS3服务器。</li>
<li>最终一致性可能导致临时过期的数据。</li>
<li>文件/文件夹的重命名操作不是原子的。</li>
<li>不支持hard link。</li>
<li>不适合用在高并发读/写的场景，这样会让系统的load升高。</li>
<li>多个客户端挂载同一个KS3 bucket时，依赖用户自行协调各个客户端的行为。例如避免多个客户端写同一个文件等等。</li>
</ul>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><ul>
<li>Q: s3fs适合什么样的程序？<br>s3fs能把ks3 bucket挂载到本地，如果您使用的软件没有支持KS3，但您又想让数据能自动同步到KS3，那么s3fs是一个很好的选择。<h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3></li>
<li>Q: s3fs一定要金山云的机器才能用么？<br>s3fs不限制一定要金山云的内网才可以使用，外网机器依然可以使用。只是内网机房有KS3的专线，保证了KS3的访问速度。<h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3></li>
<li>Q: s3fs如何Debug？<br>您可以使用在挂载时，加上-d -o f2参数，ossfs会把日志写入到系统日志中。在centos系统中，在/var/log/messages中。<br>您也可以在挂载时使用-f -d -o f2参数，ossfs会把日志输出到屏幕上。<h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3></li>
<li>Q: s3fs提示s3fs: unable to access MOUNTPOINT /mnt/ks3: No such file or directory</li>
</ul>
<h3 id="5"><a href="#5" class="headerlink" title="5"></a>5</h3><ul>
<li>Q: 如何使用supervisor启动s3fs？</li>
</ul>
<ol>
<li>安装supervisor，在ubuntu中执行sudo apt-get install supervisor</li>
<li><p>建立一个目录，编辑s3fs的启动脚本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">   mkdir /root/s3fs_scripts</div><div class="line">vi /root/s3fs_scripts/start_s3fs.sh</div><div class="line">   <span class="comment"># contents of start_s3fs.sh</span></div><div class="line">    s3fs ks3<span class="built_in">test</span> /mnt/ks3 <span class="_">-f</span> -o passwd_file=/home/lain/passwd-ks3fs -o multipart_size=100 -o parallel_count=10 -o sigv2 -o curldbg -o url=http://ks3-cn-shanghai-internal.ksyun.com</div></pre></td></tr></table></figure>
</li>
<li><p>编辑/etc/supervisor/supervisord.conf，在最后加入下面一段：</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[program:ossfs]</div><div class="line"><span class="built_in">command</span>=bash /root/s3fs_scripts/start_s3fs.sh</div><div class="line">logfile=/var/<span class="built_in">log</span>/s3fs.log</div><div class="line">log_stdout=<span class="literal">true</span></div><div class="line">log_stderr=<span class="literal">true</span></div><div class="line">logfile_maxbytes=1MB</div><div class="line">logfile_backups=10</div></pre></td></tr></table></figure>
</li>
<li><p>运行supervisor：</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">supervisord</div></pre></td></tr></table></figure>
</li>
<li><p>确认一切正常：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ps aux | grep supervisor  # 应该能看到supervisor进程</div><div class="line">ps aux | grep s3fs        # 应该能看到s3fs进程</div><div class="line">killall s3fs              # 杀掉s3fs进程，supervisor应该会重启它</div><div class="line">ps aux | grep ossfs      # 应该能看到s3fs进程</div></pre></td></tr></table></figure>
</li>
</ol>
<p>如果出错，请检查/var/log/supervisor/supervisord.log和/var/log/ossfs.log。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;KS3（Kingsoft Standard Storage Service）服务是一个对象存储类服务。类似于网盘，可以通过网络随时随地的获取存储数据。金山云为用户管理KS3存储桶提供了两种控制管理方式：金山云的后台Consol、金山云官方KS3的SDK。&lt;/p&gt;
&lt;p&gt;相比于以上两种使用场景，在实际的开发应用中，常常还有这样的场景：把KS3存储桶mount到本地文件系统，使得用户可以像操作文件目录一样操作KS3的对象。&lt;/p&gt;
&lt;p&gt;本节所介绍的S3FS fuse，就是这么一款工具；针对linux操作系统，帮助用户把KS3的桶mount到本地文件系统，使得用户操作存储桶里的数据就如同操作本地文件一样方便。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://softlns.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="KS3" scheme="https://softlns.github.io/tags/KS3/"/>
    
      <category term="S3FS-Fuse" scheme="https://softlns.github.io/tags/S3FS-Fuse/"/>
    
      <category term="数据迁移" scheme="https://softlns.github.io/tags/%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB/"/>
    
  </entry>
  
  <entry>
    <title>Rlcone使用指南</title>
    <link href="https://softlns.github.io/2016/12/06/rlcone-guide/"/>
    <id>https://softlns.github.io/2016/12/06/rlcone-guide/</id>
    <published>2016-12-06T03:14:40.000Z</published>
    <updated>2016-12-06T03:19:49.695Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Rclone是一款的命令行工具，支持在不同对象存储、网盘间同步、上传、下载数据。</p>
<p>支持的主流对象存储：</p>
<p>Google Drive<br>Amazon S3<br>Openstack Swift / Rackspace cloud files / Memset Memstore<br>Dropbox<br>Google Cloud Storage<br>Amazon Drive<br>Microsoft One Drive<br>Hubic<br>Backblaze B2<br>Yandex Disk<br>The local filesystem<br><a id="more"></a></p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h3 id="Linux下安装"><a href="#Linux下安装" class="headerlink" title="Linux下安装"></a>Linux下安装</h3><h4 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">curl -O http://downloads.rclone.org/rclone-current-linux-amd64.zip</div><div class="line">unzip rclone-current-linux-amd64.zip</div><div class="line"><span class="built_in">cd</span> rclone-*-linux-amd64</div></pre></td></tr></table></figure>
<h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo cp rclone /usr/sbin/</div><div class="line">sudo chown root:root /usr/sbin/rclone</div><div class="line">sudo chmod 755 /usr/sbin/rclone</div></pre></td></tr></table></figure>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rclone</div></pre></td></tr></table></figure>
<h3 id="MacOS下安装"><a href="#MacOS下安装" class="headerlink" title="MacOS下安装"></a>MacOS下安装</h3><h4 id="下载安装包-1"><a href="#下载安装包-1" class="headerlink" title="下载安装包"></a>下载安装包</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> &amp;&amp; curl -O http://downloads.rclone.org/rclone-current-osx-amd64.zip</div><div class="line">unzip <span class="_">-a</span> rclone-current-osx-amd64.zip &amp;&amp; <span class="built_in">cd</span> rclone-*-osx-amd64</div></pre></td></tr></table></figure>
<h3 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo mv rclone /usr/<span class="built_in">local</span>/bin/</div><div class="line"><span class="built_in">cd</span> .. &amp;&amp; rm -rf rclone-*-osx-amd64 rclone-current-osx-amd64.zip</div></pre></td></tr></table></figure>
<h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rclone config</div></pre></td></tr></table></figure>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="操作命令"><a href="#操作命令" class="headerlink" title="操作命令"></a>操作命令</h2><p>rclone命令的语法格式：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Syntax: [options] subcommand &lt;parameters&gt; &lt;parameters...&gt;</div></pre></td></tr></table></figure></p>
<p>常用的rclone命令有：</p>
<ul>
<li>rclone config - 以控制会话的形式添加rclone的配置，配置保存在.rclone.conf文件中。 </li>
<li>rclone copy - 将文件从源复制到目的地址，跳过已复制完成的。 </li>
<li>rclone  sync - 将源数据同步到目的地址，只更新目的地址的数据。   </li>
<li>rclone move - 将源数据移动到目的地址。 </li>
<li>rclone delete - 删除指定路径下的文件内容。</li>
<li>rclone purge - 清空指定路径下所有文件数据。 </li>
<li>rclone mkdir - 创建一个新目录。    </li>
<li>rclone rmdir - 删除空目录。</li>
<li>rclone check - 检查源和目的地址数据是否匹配。 </li>
<li>rclone ls - 列出指定路径下所有的文件以及文件大小和路径。 </li>
<li>rclone lsd - 列出指定路径下所有的目录/容器/桶。</li>
<li>rclone lsl - 列出指定路径下所有文件以及修改时间、文件大小和路径。</li>
<li>rclone md5sum  - 为指定路径下的所有文件产生一个md5sum文件。</li>
<li>rclone sha1sum - 为指定路径下的所有文件产生一个sha1sum文件。</li>
<li>rclone size - 获取指定路径下，文件内容的总大小。.</li>
<li>rclone version - 查看当前版本。 </li>
<li>rclone cleanup - 清空remote。</li>
<li>rclone dedupe - 交互式查找重复文件，进行删除/重命名操作。</li>
</ul>
<h3 id="rclone-config"><a href="#rclone-config" class="headerlink" title="rclone config"></a>rclone config</h3><p>开启一个交互式的配置会话。命令格式如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rclone config</div></pre></td></tr></table></figure></p>
<h3 id="rclone-copy"><a href="#rclone-copy" class="headerlink" title="rclone copy"></a>rclone copy</h3><p>将文件从源复制到目的地址，跳过已复制完成的。命令格式如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rclone copy <span class="built_in">source</span>:sourcepath dest:destpsth</div></pre></td></tr></table></figure></p>
<p>注：<br>1、rclone copy复制总是指定路径下的数据；而不是当前目录。<br>2、–no-traverse 标志用于控制是否列出目的地址目录。</p>
<h3 id="rclone-sync"><a href="#rclone-sync" class="headerlink" title="rclone sync"></a>rclone sync</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rclone sync <span class="built_in">source</span>:path dest:path</div></pre></td></tr></table></figure>
<p>注：<br>1、同步数据时，可能会删除目的地址的数据；建议先使用–dry-run标志来检查要复制、删除的数据。<br>2、同步数据出错时，不会删除任何目的地址的数据。<br>3、rclone sync同步的始终是path目录下的数据，而不是path目录。（空目录将不会被同步）</p>
<h3 id="rclone-move"><a href="#rclone-move" class="headerlink" title="rclone move"></a>rclone move</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rclone move <span class="built_in">source</span>:path dest:path</div></pre></td></tr></table></figure>
<p>注：<br>1、同步数据时，可能会删除目的地址的数据；建议先使用–dry-run标志来检查要复制、删除的数据。</p>
<h3 id="rclone-purge"><a href="#rclone-purge" class="headerlink" title="rclone purge"></a>rclone purge</h3><p>清空path目录和数据。命令格式如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rclone purge remote:path</div></pre></td></tr></table></figure></p>
<p>注：<br>1、此命令，include/exclude 过滤器失效。<br>2、删除path目录下部分数据，请使用rclone delete 命令</p>
<h3 id="rclone-mkdir"><a href="#rclone-mkdir" class="headerlink" title="rclone mkdir"></a>rclone mkdir</h3><p>创建path目录。命令格式如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rclone mkdir remote:path</div></pre></td></tr></table></figure></p>
<h3 id="rclone-rmdir"><a href="#rclone-rmdir" class="headerlink" title="rclone rmdir"></a>rclone rmdir</h3><p>删除一个空目录。命令格式如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rclone rmdir remote:path</div></pre></td></tr></table></figure></p>
<p>注：<br>1、不能删除非空的目录，删除非空目录请使用 rclone purge。</p>
<h3 id="rclone-check"><a href="#rclone-check" class="headerlink" title="rclone check"></a>rclone check</h3><p>检查源和目标地址文件是否匹配。命令格式如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rclone check <span class="built_in">source</span>:path dest:path</div></pre></td></tr></table></figure></p>
<p>注：<br>1、–size-only标志用于指定，只比较大小，不比较MD5SUMs。</p>
<h3 id="rclone-ls"><a href="#rclone-ls" class="headerlink" title="rclone ls"></a>rclone ls</h3><p>列出指定path下，所有的文件以及文件大小和路径。命令格式如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rclone ls remote:path</div></pre></td></tr></table></figure></p>
<h3 id="rclone-lsd"><a href="#rclone-lsd" class="headerlink" title="rclone lsd"></a>rclone lsd</h3><p>列出指定path下，所有目录、容器、桶。命令格式如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rclone lsd remote:path</div></pre></td></tr></table></figure></p>
<h3 id="rclone-delete"><a href="#rclone-delete" class="headerlink" title="rclone delete"></a>rclone delete</h3><p>删除指定目录的内容。命令格式如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rclone delete remote:path</div></pre></td></tr></table></figure></p>
<p>注：<br>1、不同于rclone purge，rclone delete 可使用 include/exclude 过滤器选择删除文件内容。<br>    eg：<br>    删除文件大小大于100M的文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># 先检查哪些文件将被删除</div><div class="line">rclone --min-size 100M lsl remote:path                  # 使用rclone lsl 列出大于100M的文件</div><div class="line">rclone --dry-run --min-size 100M delete remote:path    # 使用--dry-run 检查将要被删除的文件</div><div class="line">	</div><div class="line"># 使用 rclone delete 进行文件删除</div><div class="line">rclone --min-size 100M delete remote:path</div></pre></td></tr></table></figure></p>
<h3 id="rclone-size"><a href="#rclone-size" class="headerlink" title="rclone size"></a>rclone size</h3><p>获取指定path下所有数据文件的总大小。命令格式如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rclone size remote:path</div></pre></td></tr></table></figure></p>
<h3 id="more"><a href="#more" class="headerlink" title="more"></a>more</h3><p>更多rclone命令，详见<a href="http://rclone.org/commands/" target="_blank" rel="external">http://rclone.org/commands/</a> 。</p>
<h2 id="配置rclone"><a href="#配置rclone" class="headerlink" title="配置rclone"></a>配置rclone</h2><p>rclone 提供了交互式配置会话的方式来进行rclone的配置；每次配置的信息存储在.rclone.conf文件中。</p>
<h3 id="配置示例"><a href="#配置示例" class="headerlink" title="配置示例"></a>配置示例</h3><p>在这里，我们使用共享存储KS3示例，来进行rclone的配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 执行rclone config 开启配置会话</span></div><div class="line">$ rclone config </div><div class="line">No remotes found - make a new one</div><div class="line">n) New remote</div><div class="line">s) Set configuration password</div><div class="line">q) Quit config</div><div class="line">n/s/q&gt; n                     <span class="comment"># 输入n，配置一个新的remote</span></div><div class="line">name&gt; ks3-remote             <span class="comment"># 输入remote的名字，这里命名为 ks3-remote</span></div><div class="line">Type of storage to configure.</div><div class="line">Choose a number from below, or <span class="built_in">type</span> <span class="keyword">in</span> your own value</div><div class="line"> 1 / Amazon Drive</div><div class="line">   \ <span class="string">"amazon cloud drive"</span></div><div class="line"> 2 / Amazon S3 (also Dreamhost, Ceph, Minio)</div><div class="line">   \ <span class="string">"s3"</span></div><div class="line"> 3 / Backblaze B2</div><div class="line">   \ <span class="string">"b2"</span></div><div class="line"> 4 / Dropbox</div><div class="line">   \ <span class="string">"dropbox"</span></div><div class="line"> 5 / Encrypt/Decrypt a remote</div><div class="line">   \ <span class="string">"crypt"</span></div><div class="line"> 6 / Google Cloud Storage (this is not Google Drive)</div><div class="line">   \ <span class="string">"google cloud storage"</span></div><div class="line"> 7 / Google Drive</div><div class="line">   \ <span class="string">"drive"</span></div><div class="line"> 8 / Hubic</div><div class="line">   \ <span class="string">"hubic"</span></div><div class="line"> 9 / Kingsoft Cloud KS3</div><div class="line">   \ <span class="string">"ks3"</span></div><div class="line">10 / Local Disk</div><div class="line">   \ <span class="string">"local"</span></div><div class="line">11 / Microsoft OneDrive</div><div class="line">   \ <span class="string">"onedrive"</span></div><div class="line">12 / Openstack Swift (Rackspace Cloud Files, Memset Memstore, OVH)</div><div class="line">   \ <span class="string">"swift"</span></div><div class="line">13 / Yandex Disk</div><div class="line">   \ <span class="string">"yandex"</span></div><div class="line">Storage&gt; 9                   <span class="comment"># 选择9，也可直接输入ks3</span></div><div class="line">Get KS3 credentials from runtime (environment variables). Only applies <span class="keyword">if</span> access_key_id and secret_access_key is blank.</div><div class="line">Choose a number from below, or <span class="built_in">type</span> <span class="keyword">in</span> your own value</div><div class="line"> 1 / Enter KS3 credentials <span class="keyword">in</span> the next step</div><div class="line">   \ <span class="string">"false"</span></div><div class="line"> 2 / Get KS3 credentials from the environment (env vars)</div><div class="line">   \ <span class="string">"true"</span></div><div class="line">env_auth&gt; 1                 <span class="comment"># 选择1，直接配置access_key_id 和 secret_access_key  </span></div><div class="line">AWS Access Key ID - leave blank <span class="keyword">for</span> anonymous access or runtime credentials.</div><div class="line">access_key_id&gt; sgyO124X+/ZRbmgrbP7d    <span class="comment"># 键入ks3的access_key_id</span></div><div class="line">AWS Secret Access Key (password) - leave blank <span class="keyword">for</span> anonymous access or runtime credentials.</div><div class="line">secret_access_key&gt; p9/6yLzbU2FZEPw5vCPf2/buQOz1SVNdqqBtzscH    <span class="comment"># 键入ks3的secret_access_key</span></div><div class="line">Region to connect to.</div><div class="line">Choose a number from below, or <span class="built_in">type</span> <span class="keyword">in</span> your own value</div><div class="line"> 1 / Beijing Region(the default region).</div><div class="line">   \ <span class="string">"ks3-cn-beijing"</span></div><div class="line"> 2 / Hangzhou Region.</div><div class="line">   \ <span class="string">"ks3-cn-hangzhou"</span></div><div class="line"> 3 / Shanghai Region.</div><div class="line">   \ <span class="string">"ks3-cn-shanghai"</span></div><div class="line"> 4 / HongKong Region.</div><div class="line">   \ <span class="string">"ks3-cn-hk-1"</span></div><div class="line"> 5 / US West Region.</div><div class="line">   \ <span class="string">"ks3-us-west-1"</span></div><div class="line">region&gt; 1               <span class="comment"># 选择ks3的region，这里选择北京的region</span></div><div class="line">Endpoint <span class="keyword">for</span> KS3 API.</div><div class="line">Leave blank <span class="keyword">if</span> using KS3 to use the default endpoint <span class="keyword">for</span> the region.</div><div class="line">endpoint&gt;            <span class="comment"># 不使用外部的endpoint，直接回车略过</span></div><div class="line">An internal endpoint or the public endpoint <span class="keyword">for</span> KS3 access. The default is false.</div><div class="line">Choose a number from below, or <span class="built_in">type</span> <span class="keyword">in</span> your own value</div><div class="line"> 1 / Internal endpoint.</div><div class="line">   \ <span class="string">"false"</span></div><div class="line"> 2 / Public endpoint.</div><div class="line">   \ <span class="string">"true"</span></div><div class="line">internal&gt; 1          <span class="comment"># 选择1，从公网访问，不使用内网加速。 在金山云的云主机中建议选择2，使用内网加速，且不计流量。</span></div><div class="line">Canned ACL used when creating buckets and/or storing objects <span class="keyword">in</span> KS3.</div><div class="line">Choose a number from below, or <span class="built_in">type</span> <span class="keyword">in</span> your own value</div><div class="line"> 1 / Owner gets FULL_CONTROL. No one <span class="keyword">else</span> has access rights (default).</div><div class="line">   \ <span class="string">"private"</span></div><div class="line"> 2 / Owner gets FULL_CONTROL. The AllUsers group gets READ access.</div><div class="line">   \ <span class="string">"public-read"</span></div><div class="line">   / Owner gets FULL_CONTROL. The AllUsers group gets READ and WRITE access.</div><div class="line"> 3 | Granting this on a bucket is generally not recommended.</div><div class="line">   \ <span class="string">"public-read-write"</span></div><div class="line">acl&gt; 1    <span class="comment"># 选择1（私有控制）</span></div><div class="line">The server-side encryption algorithm used when storing this object <span class="keyword">in</span> S3.</div><div class="line">Choose a number from below, or <span class="built_in">type</span> <span class="keyword">in</span> your own value</div><div class="line"> 1 / None</div><div class="line">   \ <span class="string">""</span></div><div class="line"> 2 / AES256</div><div class="line">   \ <span class="string">"AES256"</span></div><div class="line">server_side_encryption&gt; 2  <span class="comment"># 选择2，使用AES256加密。</span></div><div class="line">Remote config</div><div class="line">--------------------</div><div class="line">[ks3-remote]</div><div class="line">env_auth = <span class="literal">false</span></div><div class="line">access_key_id = sgyO124X+/ZRbmgrbP7d</div><div class="line">secret_access_key = p9/6yLzbU2FZEPw5vCPf2/buQOz1SVNdqqBtzscH</div><div class="line">region = ks3-cn-beijing</div><div class="line">endpoint = </div><div class="line">internal = <span class="literal">false</span></div><div class="line">acl = private</div><div class="line">server_side_encryption = AES256</div><div class="line">--------------------</div><div class="line">y) Yes this is OK</div><div class="line">e) Edit this remote</div><div class="line">d) Delete this remote</div><div class="line">y/e/d&gt; y   <span class="comment"># 检查生成的配置，确认无误，选择y确认</span></div><div class="line">Current remotes:</div><div class="line"></div><div class="line">Name                 Type</div><div class="line">====                 ====</div><div class="line">ks3-remote           ks3</div><div class="line"></div><div class="line">e) Edit existing remote</div><div class="line">n) New remote</div><div class="line">d) Delete remote</div><div class="line">s) Set configuration password</div><div class="line">q) Quit config</div><div class="line">e/n/d/s/q&gt; q  <span class="comment"># 配置完成，选择q退出。</span></div></pre></td></tr></table></figure>
<p>配置完成，检查生成的配置文件~/.rclone.conf:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ more ~/.rclone.conf</div><div class="line">[ks3-remote]          <span class="comment"># 远程存储的名称：ks3-remote</span></div><div class="line"><span class="built_in">type</span> = ks3            <span class="comment"># 远程存储的类型：ks3</span></div><div class="line">env_auth = <span class="literal">false</span>      <span class="comment"># 是否从环境变量中读取access_key和secret_key </span></div><div class="line">access_key_id = sgyO124X+/ZRbmgrbP7d   <span class="comment"># 当前ks3的access_key</span></div><div class="line">secret_access_key = p9/6yLzbU2FZEPw5vCPf2/buQOz1SVNdqqBtzscH  <span class="comment"># 当前ks3的secret_key</span></div><div class="line">region = ks3-cn-beijing  <span class="comment"># 所使用ks3的region名称</span></div><div class="line">endpoint =            <span class="comment"># 是否使用外部endpoint</span></div><div class="line">internal = <span class="literal">false</span>      <span class="comment"># 是否从内网访问</span></div><div class="line">acl = private         <span class="comment"># 访问控制策略：私有控制</span></div><div class="line">server_side_encryption = AES256 <span class="comment"># 加密</span></div></pre></td></tr></table></figure></p>
<h3 id="测试配置"><a href="#测试配置" class="headerlink" title="测试配置"></a>测试配置</h3><p>查看上述配置远程存储所有的桶：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ rclone lsd ks3-remote:</div><div class="line">          -1 2016-06-07 07:26:04        -1 dockertest2</div><div class="line">          -1 2016-11-21 08:24:52        -1 ks3-fs-test</div><div class="line">2016/11/28 15:26:25 </div><div class="line">Transferred:      0 Bytes (0 Bytes/s)</div><div class="line">Errors:                 0</div><div class="line">Checks:                 0</div><div class="line">Transferred:            0</div><div class="line">Elapsed time:       200ms</div></pre></td></tr></table></figure></p>
<h2 id="一些实用场景"><a href="#一些实用场景" class="headerlink" title="一些实用场景"></a>一些实用场景</h2><h3 id="将本地目录同步到ks3"><a href="#将本地目录同步到ks3" class="headerlink" title="将本地目录同步到ks3"></a>将本地目录同步到ks3</h3><p>一般，由于对象存储具有廉价、高可用、安全、可靠等特性；我们通常会用作本地数据（日志、图片、视频）的存储或是备份。通常在使用对象存储存储数据时，往往需要调用官方的SDK，需要一定的开发量。尤其当我们仅仅是需要备份某个盘或是目录下的日志时，这时候使用rclone这样的命令行工具，能方便把数据存储（或备份）到远程存储上，且不受文件大小的限制（比如ks3单个文件上传大小不能超过5G）。</p>
<p>比如，将/home/local/directory同步到远程存储的某个bucket中，操作命令如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rclone sync /home/<span class="built_in">local</span>/directory remote:bucket</div></pre></td></tr></table></figure></p>
<h3 id="AWS-s3-迁移到-KS3"><a href="#AWS-s3-迁移到-KS3" class="headerlink" title="AWS s3 迁移到 KS3"></a>AWS s3 迁移到 KS3</h3><p>由于s3的region多建在国外，s3的资费相对较高。那么将一部分数据迁移到KS3，是比较经济的。除了使用KS3官方提供的镜像服务，可以别的远程存储迁移到KS3；rclone为此提供了另外一种可能。</p>
<p>比如将远程存储s3的桶s3-log，迁移到远程存储ks3的桶ks3-log:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rclone sync s3-remote:s3-log ks3-remote:ks3-log</div></pre></td></tr></table></figure></p>
<p>远程存储s3-remote、ks3-remote的配置信息如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">[s3-remote]</div><div class="line"><span class="built_in">type</span> = s3-remote</div><div class="line">env_auth = <span class="literal">false</span></div><div class="line">access_key_id = AKIAJTT3FZHMRQSXFZFQ</div><div class="line">secret_access_key = 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</div><div class="line">region = ap-northeast-2</div><div class="line">endpoint = </div><div class="line">location_constraint = ap-northeast-2</div><div class="line">acl = private</div><div class="line">server_side_encryption = AES256</div><div class="line">storage_class = </div><div class="line"></div><div class="line">[ks3-remote]</div><div class="line"><span class="built_in">type</span> = ks3</div><div class="line">env_auth = <span class="literal">false</span></div><div class="line">access_key_id = sgyO124X+/ZRbmgrbP7d</div><div class="line">secret_access_key = p9/6yLzbU2FZEPw5vCPf2/buQOz1SVNdqqBtzscH</div><div class="line">region = ks3-cn-beijing</div><div class="line">endpoint = </div><div class="line">internal = <span class="literal">false</span></div><div class="line">acl = private</div><div class="line">server_side_encryption = AES256</div></pre></td></tr></table></figure></p>
<h3 id="KS3-bucket之间的同步"><a href="#KS3-bucket之间的同步" class="headerlink" title="KS3 bucket之间的同步"></a>KS3 bucket之间的同步</h3><p>KS3对象存储不支持使用KS3存储的桶作为另一个桶的镜像。</p>
<p>比如：我们需要搭建一个大型的docker hub，为了保证不同地域用户下载和上传速度（虽然KS3自带CDN），需要在北京、上海分别建立两个镜像中心；这样在拉取镜像时，南方用户只需要去上海的镜像中心拉取数据，北方用户则到北京镜像中心拉取数据；极大地提高数据的访问速度。<br>那么类似这样的需求，我们不得不保持两个镜像中心的数据一致性；在不适用官方SDK的情况下，我们可以使用rclone sync同步不同region下bucket中的数据：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rclone sync ks3-beijing:bucket1 ks3-shanghai:bucket2</div></pre></td></tr></table></figure></p>
<p>注：<br>即便bucket1与bucket2共用一套账户体系，即ks3-beijing 和 ks3-shanghai的access_key_id和secret_access_key是一样的。仍然需要分别建立 ks3-beijing 和 ks3-shanghai 两个远程存储的配置。<br>例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">$ more ~/.rclone</div><div class="line">[ks3-beijing]                                                                                               </div><div class="line"><span class="built_in">type</span> = ks3  </div><div class="line">env_auth = <span class="literal">false</span></div><div class="line">access_key_id = sgyO124X+/ZRbmgrbP7d</div><div class="line">secret_access_key = p9/6yLzbU2FZEPw5vCPf2/buQOz1SVNdqqBtzscH</div><div class="line">region = ks3-cn-beijing</div><div class="line">endpoint =  </div><div class="line">internal = <span class="literal">true</span></div><div class="line">acl = private</div><div class="line">server_side_encryption = AES256</div><div class="line">              </div><div class="line">              </div><div class="line">[ks3-shanghai]  </div><div class="line"><span class="built_in">type</span> = ks3  </div><div class="line">env_auth = <span class="literal">false</span></div><div class="line">access_key_id = sgyO124X+/ZRbmgrbP7d</div><div class="line">secret_access_key = p9/6yLzbU2FZEPw5vCPf2/buQOz1SVNdqqBtzscH</div><div class="line">region = ks3-cn-shanghai</div><div class="line">endpoint =  </div><div class="line">internal = <span class="literal">true</span></div><div class="line">acl = private</div><div class="line">server_side_encryption = AES256</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;Rclone是一款的命令行工具，支持在不同对象存储、网盘间同步、上传、下载数据。&lt;/p&gt;
&lt;p&gt;支持的主流对象存储：&lt;/p&gt;
&lt;p&gt;Google Drive&lt;br&gt;Amazon S3&lt;br&gt;Openstack Swift / Rackspace cloud files / Memset Memstore&lt;br&gt;Dropbox&lt;br&gt;Google Cloud Storage&lt;br&gt;Amazon Drive&lt;br&gt;Microsoft One Drive&lt;br&gt;Hubic&lt;br&gt;Backblaze B2&lt;br&gt;Yandex Disk&lt;br&gt;The local filesystem&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="https://softlns.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="KS3" scheme="https://softlns.github.io/tags/KS3/"/>
    
      <category term="Rclone" scheme="https://softlns.github.io/tags/Rclone/"/>
    
      <category term="S3" scheme="https://softlns.github.io/tags/S3/"/>
    
      <category term="共享存储" scheme="https://softlns.github.io/tags/%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>基于Jenkins、Gitlab构建持续集成、持续交付的Docker容器集群</title>
    <link href="https://softlns.github.io/2016/12/06/jenkins-gitlab-docker/"/>
    <id>https://softlns.github.io/2016/12/06/jenkins-gitlab-docker/</id>
    <published>2016-12-06T03:04:54.000Z</published>
    <updated>2016-12-06T03:13:45.017Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>基于Jenkins、Gitlab构建持续集成、持续交付的Docker容器集群。</p>
<a id="more"></a>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ul>
<li>Linux系统（以ubuntu示例）</li>
<li>Docker运行环境</li>
<li>docker-compose编排工具</li>
</ul>
<h3 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h3><p>安装Docker执行以下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -fsSL https://get.docker.io | bash</div></pre></td></tr></table></figure></p>
<p>注：升级内核</p>
<h3 id="安装docker-compose"><a href="#安装docker-compose" class="headerlink" title="安装docker-compose"></a>安装docker-compose</h3><p>默认的[官方文档][]安装命令如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -L https://github.com/docker/compose/releases/download/1.6.2/docker-compose-`uname <span class="_">-s</span>`-`uname -m` &gt; /usr/<span class="built_in">local</span>/bin/docker-compose</div></pre></td></tr></table></figure></p>
<h2 id="搭建基础服务"><a href="#搭建基础服务" class="headerlink" title="搭建基础服务"></a>搭建基础服务</h2><p>CI、CD涉及的基础服务有：</p>
<ol>
<li>代码仓库（以Gitlab示例）</li>
<li>镜像仓库（以搭建私有镜像仓库示例）</li>
<li>代码构建（以Jenkins示例）</li>
<li>容器集群（以swarm示例）</li>
</ol>
<h3 id="代码仓库（构建Gitlab服务）"><a href="#代码仓库（构建Gitlab服务）" class="headerlink" title="代码仓库（构建Gitlab服务）"></a>代码仓库（构建Gitlab服务）</h3><p><a href="https://about.gitlab.com/" target="_blank" rel="external">GitLab</a>是一个利用 Ruby on Rails 开发的开源应用程序，实现一个自托管的Git项目仓库，可通过Web界面进行访问公开的或者私人项目；类似于Github。</p>
<p>选一台主机以docker化的方式来搭建Gitlab服务。（已有私有Gitlab仓库或使用Github，可跳过此步骤）</p>
<p>我们选择Docker Hub上的<a href="https://hub.docker.com/r/sameersbn/gitlab/" target="_blank" rel="external">sameersbn/gitlab</a>镜像来快速构建Gitlab服务。<br>根据<a href="https://github.com/sameersbn/docker-gitlab/blob/master/README.md" target="_blank" rel="external">sameersbn/docker-gitlab给出的文档</a>，我们需要启动三个容器组件.</p>
<h4 id="Docker-cli启动方式"><a href="#Docker-cli启动方式" class="headerlink" title="Docker cli启动方式"></a>Docker cli启动方式</h4><ul>
<li>启动postgresql容器（可使用外部数据、也可使用mqsql存储，具体参见文档）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">docker run --name gitlab-postgresql <span class="_">-d</span> \</div><div class="line">    --env <span class="string">'DB_NAME=gitlabhq_production'</span> \</div><div class="line">    --env <span class="string">'DB_USER=gitlab'</span> \ </div><div class="line">	--env <span class="string">'DB_PASS=password'</span> \</div><div class="line">    --env <span class="string">'DB_EXTENSION=pg_trgm'</span> \</div><div class="line">    --volume /srv/docker/gitlab/postgresql:/var/lib/postgresql \</div><div class="line">    sameersbn/postgresql:9.5-3</div></pre></td></tr></table></figure>
<ul>
<li><p>启动redis容器</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">docker run --name gitlab-redis <span class="_">-d</span> \</div><div class="line">    --volume /srv/docker/gitlab/redis:/var/lib/redis \</div><div class="line">    sameersbn/redis:latest</div></pre></td></tr></table></figure>
</li>
<li><p>启动gitlab容器</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">docker run --name gitlab <span class="_">-d</span> \</div><div class="line">    --link gitlab-postgresql:postgresql --link gitlab-redis:redisio \</div><div class="line">    --publish 10022:22 --publish 10080:80 \</div><div class="line">    --env <span class="string">'GITLAB_PORT=10080'</span> \</div><div class="line">	--env <span class="string">'GITLAB_SSH_PORT=10022'</span> \</div><div class="line">    --env <span class="string">'GITLAB_SECR</span></div><div class="line">	ETS_DB_KEY_BASE=long-and-random-alpha-numeric-string' \</div><div class="line">    --env <span class="string">'GITLAB_SECRETS_SECRET_KEY_BASE=long-and-random-alpha-numeric-string'</span> \</div><div class="line">    --env <span class="string">'GITLAB_SECRETS_OTP_KEY_BASE=long-and-random-alpha-numeric-string'</span> \</div><div class="line">    --volume /srv/docker/gitlab/gitlab:/home/git/data \</div><div class="line">    sameersbn/gitlab:latest</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="docker-compose启动方式"><a href="#docker-compose启动方式" class="headerlink" title="docker-compose启动方式"></a>docker-compose启动方式</h4><p>通常处理复杂容器之间的配置依赖关系可以使用docker-compose工具来管理，用法参见<a href="https://docs.docker.com/compose/" target="_blank" rel="external">docker-compose文档</a>。</p>
<p>使用docker-compose的启动方式，需要docker-compose.yml文件，内容如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">gitlab:</div><div class="line">  image: sameersbn/gitlab</div><div class="line">  ports:</div><div class="line">    - <span class="string">"10022:22"</span></div><div class="line">    - <span class="string">"10080:80"</span></div><div class="line">  links:</div><div class="line">    - gitlab-redis:redisio</div><div class="line">    - gitlab-postgresql:postgresql</div><div class="line">  environment:</div><div class="line">    - GITLAB_PORT=80</div><div class="line">    - GITLAB_SSH_PORT=22</div><div class="line">    - GITLAB_SECRETS_DB_KEY_BASE=long-and-random-alpha-numeric-string</div><div class="line">    - GITLAB_SECRETS_SECRET_KEY_BASE=long-and-random-alpha-numeric-string</div><div class="line">    - GITLAB_SECRETS_OTP_KEY_BASE=long-and-random-alpha-numeric-string</div><div class="line">  volumes:</div><div class="line">    - /srv/docker/gitlab/gitlab:/home/git/data</div><div class="line">  restart: always</div><div class="line"></div><div class="line">gitlab-redis:</div><div class="line">  image: sameersbn/redis</div><div class="line">  volumes:</div><div class="line">    - /srv/docker/gitlab/redis:/var/lib/redis</div><div class="line">  restart: always</div><div class="line"></div><div class="line">gitlab-postgresql:</div><div class="line">  image: sameersbn/postgresql:9.5-3</div><div class="line">  environment:</div><div class="line">    - DB_NAME=gitlabhq_production</div><div class="line">    - DB_USER=gitlab</div><div class="line">    - DB_PASS=password</div><div class="line">    - DB_EXTENSION=pg_trgm</div><div class="line">  volumes:</div><div class="line">    - /srv/docker/gitlab/postgresql:/var/lib/postgresql</div><div class="line">  restart: always</div></pre></td></tr></table></figure></p>
<p>执行以下命令，构建gitlab服务<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker-compose up <span class="_">-d</span></div></pre></td></tr></table></figure></p>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>执行docker ps命令查看：</p>
<p><img src="/images/1478836346389.jpg" alt="docker ps 结果显示" title="Gitlab 相关容器运行状态"></p>
<p>访问\<your host\="">:10080，查看Gitlab网页是否正常，并设置root账初始密码。</your></p>
<h3 id="镜像仓库（构建Docker私有仓库）"><a href="#镜像仓库（构建Docker私有仓库）" class="headerlink" title="镜像仓库（构建Docker私有仓库）"></a>镜像仓库（构建Docker私有仓库）</h3><p>镜像管理是Docker容器的核心，Docker官方在Github上有一个项目<a href="https://github.com/docker/distribution" target="_blank" rel="external">docker-registry</a>, 专门用于自建Docker的私有镜像库。</p>
<p>在CI、CD中，需要一个Docker镜像仓库来存放每次构建的镜像（使用公有镜像仓库如Docker Hub可以自行跳过）。<br>从镜像的安全、可靠、访问速度等因素考虑，搭建一个私有的镜像仓库，对企业级开发和实践是很有必要的。</p>
<h4 id="Docker-cli构建方式"><a href="#Docker-cli构建方式" class="headerlink" title="Docker cli构建方式"></a>Docker cli构建方式</h4><p>最简便的创建方式：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker run <span class="_">-d</span>  --restart=always --name registry \</div><div class="line"> -v  /mnt/docker/registry:/var/lib/registry  -p 5000:5000 registry:2</div></pre></td></tr></table></figure></p>
<h4 id="docker-compose构建方式"><a href="#docker-compose构建方式" class="headerlink" title="docker-compose构建方式"></a>docker-compose构建方式</h4><p> 编写docker-compose.yml文件，内容如下：<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">registry:</div><div class="line"> image: registry:2</div><div class="line"> ports:</div><div class="line">   - <span class="string">"5000:5000"</span></div><div class="line"> volumes:</div><div class="line">   - /mnt/docker/registry:/var/lib/registry</div><div class="line"> restart: always</div></pre></td></tr></table></figure></p>
<p>执行docker-compose up -d命令</p>
<h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><ul>
<li>执行docker ps 可查看registry容器运行状态。</li>
<li>测试推送/拉取 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker pull 		镜像仓库ip:端口/&lt;命名空间&gt;/项目名称	<span class="comment">#  拉取镜像</span></div><div class="line">docker push       镜像仓库ip:端口/&lt;命名空间&gt;/项目名称	  <span class="comment"># 推送镜像</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>注：docker私有镜像仓库 拉取/推送 失败，提示不能使用http连接。解决方法：<br>1、设置https访问，参见<a href="https://softlns.github.io/2016/11/07/create-ks3-harbor-registry/#more">企业级的Docker Registry搭建</a>。<br>2、在docker启动参数里添加–insecure-registry \<your registry="" host\="">:\<port\>，然后重启docker。</port\></your></p>
<h3 id="镜像构建（搭建Jenkins服务）"><a href="#镜像构建（搭建Jenkins服务）" class="headerlink" title="镜像构建（搭建Jenkins服务）"></a>镜像构建（搭建Jenkins服务）</h3><p>Jenkins是基于Java开发的一种开源持续集成工具，监控并触发持续重复的工作，具有开源，支持多平台和插件扩展，安装简单，界面化管理等特点。Jenkins使用job来描述每一步工作，节点是用来执行项目的环境。Master节点是Jenkins job的默认执行环境，也是Jenkins应用本身的安装环境<br>使用官方的Jenkins镜像来构建我们的Jenkins服务。</p>
<h4 id="Docker-cli构建方式-1"><a href="#Docker-cli构建方式-1" class="headerlink" title="Docker cli构建方式"></a>Docker cli构建方式</h4><p>执行以下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">docker run  docker run  <span class="_">-d</span>  -p 8080:8080 \</div><div class="line">--name jenkins  --restart=always -v /mnt/jenkins_home:/var/jenkins_home \</div><div class="line">-v /var/run/docker.sock:/var/run/docker.sock   jayqqaa12/jenkins</div></pre></td></tr></table></figure></p>
<p>参数说明：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-v /mnt/jenkins_home:/var/jenkins_home   <span class="comment"># 映射volumes到本地存储</span></div><div class="line">-v /var/run/docker.sock:/var/run/docker.sock  <span class="comment"># 映射主机的docker到容器里面 这样在容器里面就可以使用主机安装的 docker 了</span></div></pre></td></tr></table></figure></p>
<h4 id="docker-compose构建方式-1"><a href="#docker-compose构建方式-1" class="headerlink" title="docker-compose构建方式"></a>docker-compose构建方式</h4><p>编写docker-compose.yml文件，内容如下：<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">jenkins:</div><div class="line"> image: jayqqaa12/jenkins</div><div class="line"> ports:</div><div class="line">   - <span class="string">"8080:8080"</span></div><div class="line"> volumes:</div><div class="line">   - /var/run/docker.sock:/var/run/docker.sock</div><div class="line">   - /mnt/jenkins_home:/var/jenkins_home</div><div class="line"> restart: always</div></pre></td></tr></table></figure></p>
<p>  执行docker-compose up -d命令</p>
<h4 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h4><ul>
<li>执行docker ps 查看jenkins容器运行情况</li>
<li>在浏览器中，打开http://\<your jenkins="" host\="">:8080，进入jenkins，默认用户/密码（admin/admin）</your></li>
</ul>
<h3 id="容器集群（构建Docker-Swarm集群）"><a href="#容器集群（构建Docker-Swarm集群）" class="headerlink" title="容器集群（构建Docker Swarm集群）"></a>容器集群（构建Docker Swarm集群）</h3><p>容器集群管理工具主要有k8s、mesos、swarm，以及从Docker1.12版本出现的swarmkit。这里以swarm示例容器集群的简单操作。</p>
<p>Swarm是Docker官方发布的一套较为简单的容器集群管理工具，它将一群Docker宿主机变成一个单一的虚拟主机。Swarm使用标准的Docker API接口，因此能可以很方便地和docker的标准API进行集成。</p>
<p>下面，使用Docker-Swarm来创建一个docker容器集群</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#创建一个swarm集群 ，会返回一个token来替换下面命令的&lt;token&gt;</span></div><div class="line">docker run --rm swarm create </div><div class="line"> </div><div class="line"><span class="comment"># 创建集群的管理容器swarm  来管理所有节点 </span></div><div class="line">docker run <span class="_">-d</span> --name swarm-manage --restart=always -p \</div><div class="line">2376:2375 swarm manage token://&lt;token&gt;</div><div class="line"> </div><div class="line"><span class="comment">#添加节点到swarm集群中  </span></div><div class="line">docker run <span class="_">-d</span> --restart=always --name swarm-agent swarm \</div><div class="line">join --addr=当前服务器的ip:2375 token://&lt;token&gt;</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#查看集群的节点信息 </span></div><div class="line">docker -H 管理节点的ip:2376 info</div></pre></td></tr></table></figure>
<p>查看当前集群信息，只有一个节点：</p>
<p><img src="/images/1478851124897.jpg" alt="swarm集群信息" title="集群信息.jpg"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker -H 管理节点的ip:2376 run  xxx   <span class="comment">#运行容器</span></div><div class="line">docker -H 管理节点的ip:2376 ps  xxx    <span class="comment">#查看集群容器运行情况</span></div></pre></td></tr></table></figure>
<p>以上是使用swarm集群运行、查看容器，更多swarm集群操作详见<a href="https://github.com/docker/swarm" target="_blank" rel="external">swarm文档</a>。</p>
<p>注：节点发现无法连接，则需要在Docker daemon添加启动参数：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">--insecure-registry &lt;镜像仓库host&gt;:&lt;port&gt; 		  <span class="comment"># 设置仓库为http访问  </span></div><div class="line">-H unix:///var/run/docker.sock  -H 0.0.0.0:2375  <span class="comment">#打开节点对外通信接口 </span></div><div class="line">--label label_name=swarm-node1 					  <span class="comment"># 设置一下label 方便区分</span></div></pre></td></tr></table></figure></p>
<h2 id="Demo-基于Docker构建持续集成（CI）、持续部署（CD）的Flask项目"><a href="#Demo-基于Docker构建持续集成（CI）、持续部署（CD）的Flask项目" class="headerlink" title="Demo: 基于Docker构建持续集成（CI）、持续部署（CD）的Flask项目"></a>Demo: 基于Docker构建持续集成（CI）、持续部署（CD）的Flask项目</h2><p>以上，我们搭建了基于Docker的CI、CD的基础服务，下面我们创建一个Flask项目的Demo来测试下：</p>
<ol>
<li>在gitlab创建python-hello-world项目仓库</li>
<li>clone项目，本地开发</li>
<li>配置jenkins</li>
<li>触发构建</li>
</ol>
<h3 id="gitlab上新建项目"><a href="#gitlab上新建项目" class="headerlink" title="gitlab上新建项目"></a>gitlab上新建项目</h3><p>在gitlab创建python-hello-world项目仓库。</p>
<p><img src="/images/1478853924711.jpg" alt="enter description here" title="gitlab项目信息"></p>
<h3 id="本地开发"><a href="#本地开发" class="headerlink" title="本地开发"></a>本地开发</h3><h4 id="编写Flask应用"><a href="#编写Flask应用" class="headerlink" title="编写Flask应用"></a>编写Flask应用</h4><p>创建app.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</div><div class="line"></div><div class="line">app = Flask(__name__)</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">@app.route('/')</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">"Hello World! &lt;br/&gt; version: v1   author: lain"</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    app.run(host=<span class="string">"0.0.0.0"</span>, port=<span class="number">5000</span>)</div></pre></td></tr></table></figure></p>
<p>创建requirements.txt:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">flask</div></pre></td></tr></table></figure></p>
<h3 id="编写Dockerfile"><a href="#编写Dockerfile" class="headerlink" title="编写Dockerfile"></a>编写Dockerfile</h3><p>创建Dockerfile<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">From python:2.7</div><div class="line"></div><div class="line">MAINTAINER lain</div><div class="line"></div><div class="line">ADD . /app</div><div class="line"></div><div class="line">WORKDIR ./app</div><div class="line"></div><div class="line">RUN pip install -r requirements.txt</div><div class="line"></div><div class="line">EXPOSE 5000</div><div class="line"></div><div class="line">CMD [<span class="string">"python"</span>, <span class="string">"/app/hello.py"</span>]</div></pre></td></tr></table></figure></p>
<h4 id="创建构建部署脚本"><a href="#创建构建部署脚本" class="headerlink" title="创建构建部署脚本"></a>创建构建部署脚本</h4><p>创建build_deploy.sh<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"></div><div class="line"><span class="comment">#build in jenkins</span></div><div class="line"></div><div class="line"><span class="comment"># docker私有仓库的地址</span></div><div class="line">REG_URL=xxxx</div><div class="line"></div><div class="line"><span class="comment"># swarm集群manage节点的地址</span></div><div class="line">SWARM_MANAGE_URL=xx:2376</div><div class="line"></div><div class="line"><span class="comment">#根据时间生成tag</span></div><div class="line">TAG=<span class="variable">$REG_URL</span>/<span class="variable">$JOB_NAME</span>:`date +%y%m%d-%H-%M`</div><div class="line"></div><div class="line"><span class="comment">#使用项目目录下的Dockerfile文件打包 </span></div><div class="line">docker build -t  <span class="variable">$TAG</span>  <span class="variable">$WORKSPACE</span>/.</div><div class="line">docker push   <span class="variable">$TAG</span></div><div class="line">docker rmi <span class="variable">$TAG</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 检测是否有运行的版本，有就删了</span></div><div class="line"><span class="keyword">if</span> docker -H <span class="variable">$SWARM_MANAGE_URL</span> ps <span class="_">-a</span>| grep -i <span class="variable">$JOB_NAME</span>; <span class="keyword">then</span></div><div class="line">        docker -H <span class="variable">$SWARM_MANAGE_URL</span> rm <span class="_">-f</span>  <span class="variable">$JOB_NAME</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"><span class="comment">#在swarm集群运行</span></div><div class="line">docker -H <span class="variable">$SWARM_MANAGE_URL</span> run  <span class="_">-d</span>  -p 80:5000  --name <span class="variable">$JOB_NAME</span>  <span class="variable">$TAG</span></div></pre></td></tr></table></figure></p>
<h3 id="配置Jenkins"><a href="#配置Jenkins" class="headerlink" title="配置Jenkins"></a>配置Jenkins</h3><p>在Jenkins上创建一个python-hello-world项目，选择自由风格即可：</p>
<p><img src="/images/1479044880231.jpg" alt="enter description here" title="jenkins新建项目"></p>
<p>设置git:</p>
<p><img src="/images/1479045060175.jpg" alt="enter description here" title="jenkins配置git"></p>
<p>设置构建触发器，这里设置每分钟拉取一次，也可设置gitlab hook：</p>
<p><img src="/images/1479045355005.jpg" alt="enter description here" title="jenkins配置触发器"></p>
<p>设置构建需要执行的脚本，这里设置成build_deploy.sh:</p>
<p><img src="/images/1479045561748.jpg" alt="enter description here" title="jenkins配置执行脚本"></p>
<h3 id="触发CI、CD"><a href="#触发CI、CD" class="headerlink" title="触发CI、CD"></a>触发CI、CD</h3><p>推送到代码到gitlab的master分支，然后查看jenkins console，就可以查看到构建集成和部署的过程。</p>
<p><img src="/images/1479089385376.jpg" alt="enter description here" title="jenkins构建日志"></p>
<h3 id="访问测试"><a href="#访问测试" class="headerlink" title="访问测试"></a>访问测试</h3><p>访问浏览器，已经部署到swarm集群（关于集群的负载均衡，请自行查阅。）</p>
<p><img src="/images/1479090215977.jpg" alt="enter description here" title="网站页面"></p>
<p>更新代码版本，并推送到代码仓库gilab：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</div><div class="line"></div><div class="line">app = Flask(__name__)</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">@app.route('/')</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">"Hello World! &lt;br/&gt; version: v2   author: lain"</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    app.run(host=<span class="string">"0.0.0.0"</span>, port=<span class="number">5000</span>)</div></pre></td></tr></table></figure></p>
<p>等待2分钟，可以在jenkins查看到新的构建是否成功，访问浏览器：</p>
<p><img src="/images/1479090668198.jpg" alt="enter description here" title="变更后网页信息"></p>
<h2 id="容器监控"><a href="#容器监控" class="headerlink" title="容器监控"></a>容器监控</h2><p>关于采集容器运行信息数据、查看容器运行情况、日志等，通过命令行的方式是很不方便的，因此我们需要搭建一个容器监控平台，开源的工具有<br>如何管理容器 查看容器运行情况 日志等都不太方便 我们需要搭建一个监控平台cAdvisor等。（这里不再叙述）</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;基于Jenkins、Gitlab构建持续集成、持续交付的Docker容器集群。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://softlns.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Docker" scheme="https://softlns.github.io/tags/Docker/"/>
    
      <category term="Jenkins" scheme="https://softlns.github.io/tags/Jenkins/"/>
    
      <category term="Gitlab" scheme="https://softlns.github.io/tags/Gitlab/"/>
    
      <category term="Swarm" scheme="https://softlns.github.io/tags/Swarm/"/>
    
      <category term="持续集成" scheme="https://softlns.github.io/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
      <category term="持续构建" scheme="https://softlns.github.io/tags/%E6%8C%81%E7%BB%AD%E6%9E%84%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>基于KS3、Harbor搭建企业级的Docker</title>
    <link href="https://softlns.github.io/2016/11/07/create-ks3-harbor-registry/"/>
    <id>https://softlns.github.io/2016/11/07/create-ks3-harbor-registry/</id>
    <published>2016-11-07T12:56:14.000Z</published>
    <updated>2016-12-06T03:12:08.179Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Harbor 是 VMware 中国开发的一款 Docker Registry 工具，其主要致力于企业级的 Registry 管理，并提供了 LDAP 等高级权限认证功能。</p>
<p>KS3（Kingsoft Standard Storage Service）是金山云为企业用户提供的无限制、多备份、分布式的低成本存储空间服务，解决存储扩容、数据可靠安全以及分布式访问等相关复杂问题。</p>
<p>本文介绍了如何使用基于KS3存储搭建Harbor企业级的Registry镜像仓库管理。<br><a id="more"></a></p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>Docker Registry v2需要运行在有Docker环境的主机上，Harbor项目是以容器化的方式来启动的，各组件容器之间的依赖由docker-compose管理。</p>
<h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ul>
<li>Linux系统 （本文以ubuntu示例）</li>
<li>Docker运行环境</li>
<li>docker-compose编排工具</li>
</ul>
<h3 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h3><p>执行以下命令安装 Docker<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ curl -fsSL https://get.docker.io | bash</div></pre></td></tr></table></figure></p>
<h3 id="安装docker-compose"><a href="#安装docker-compose" class="headerlink" title="安装docker-compose"></a>安装docker-compose</h3><p>默认的<a href="https://docs.docker.com/compose/install" target="_blank" rel="external">官方文档</a> 安装命令如下 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -L https://github.com/docker/compose/releases/download/1.6.2/docker-compose-`uname <span class="_">-s</span>`-`uname -m` &gt; /usr/<span class="built_in">local</span>/bin/docker-compose</div></pre></td></tr></table></figure></p>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>安装部署步骤如下：</p>
<ol>
<li>下载安装包</li>
<li>配置harbor</li>
<li>配置后端存储到KS3</li>
<li>配置HTTPS</li>
<li>执行安装脚本并启动Harbor</li>
<li>测试</li>
</ol>
<h3 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h3><p>Harbor发行版的安装包可以在GItHub下载，有在线（online）安装和离线（offline）安装两种安装方式选择。</p>
<p>以在线安装示例，通过wget命令下载，使用tar命令将其解压，目录结构如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">wget https://github.com/vmware/harbor/releases/download/0.4.5/harbor-online-installer-0.4.5.tgz</div><div class="line">tar -zxvf harbor-online-installer-0.4.5.tgz</div></pre></td></tr></table></figure>
<p><img src="/images/1480991782937.jpg" alt="Harbor在线安装包目录结构" title="Harbor在线安装包目录结构"></p>
<p>其中：</p>
<blockquote>
<p>install.sh 是用于安装Harbor安装脚本<br>config 目录存放了harbor的配置数据，如registry 和 ui目录中存放了相关证书用于组件间加密通讯<br>harbor.cfg 是全局配置文件，主要包含了一些常用设置，比如是否启用https等<br>prepare 是一个python写的预处理脚本，主要用于初始化一些harbor.cfg的相关设置<br>docker-compose.yml 描述了个组件之间依赖关系以及配置挂载，数据持久化等设置。</p>
</blockquote>
<h3 id="配置Harbor"><a href="#配置Harbor" class="headerlink" title="配置Harbor"></a>配置Harbor</h3><p>Harbor的常用配置参数主要存放在harbor.cfg，直接编辑harbor.cfg即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">vim harbor.cfg</div><div class="line"><span class="comment"># 其配置信息如下</span></div><div class="line">hostname = reg.yourdomain.com                     <span class="comment"># Harbor 服务器域名</span></div><div class="line">ui_url_protocol = https                           <span class="comment"># UI 组件访问协议</span></div><div class="line">email_server = smtp.mydomain.com                  <span class="comment"># email 服务器地址</span></div><div class="line">email_server_port = 25                            <span class="comment"># email 端口</span></div><div class="line">email_username = sample_admin@mydomain.com        <span class="comment"># email 账号</span></div><div class="line">email_password = abc                              <span class="comment"># email 密码</span></div><div class="line">email_from = admin &lt;sample_admin@mydomain.com&gt;    <span class="comment"># email 发件人</span></div><div class="line">email_ssl = <span class="literal">false</span>                                 <span class="comment"># 是否启用 SSL</span></div><div class="line">harbor_admin_password = Harbor12345               <span class="comment"># Harbor 初始化管理员(admin)密码</span></div><div class="line">auth_mode = db_auth                               <span class="comment"># 权限管理模型(db_auth/ldap_auth)</span></div><div class="line">ldap_url = ldaps://ldap.mydomain.com              <span class="comment"># ldap 地址</span></div><div class="line">ldap_basedn = uid=%s,ou=people,dc=mydomain,dc=com <span class="comment"># ldap 权限模型</span></div><div class="line">db_password = root123                             <span class="comment"># 数据库 管理员密码</span></div><div class="line">self_registration = on                            <span class="comment"># 是否打开自动注册</span></div><div class="line">use_compressed_js = on                            <span class="comment"># 是否启用压缩js</span></div><div class="line">max_job_workers = 3                               <span class="comment"># 最大任务数</span></div><div class="line">token_expiration = 30                             <span class="comment"># token 超时</span></div><div class="line">verify_remote_cert = on                           <span class="comment"># 是否验证远程证书</span></div><div class="line">customize_crt = on                                <span class="comment"># 是否启用自定义证书</span></div><div class="line"><span class="comment"># 以下为自定义证书信息</span></div><div class="line">crt_country = CN</div><div class="line">crt_state = State</div><div class="line">crt_location = CN</div><div class="line">crt_organization = organization</div><div class="line">crt_organizationalunit = organizational unit</div><div class="line">crt_commonname = example.com</div><div class="line">crt_email = example@example.com</div></pre></td></tr></table></figure>
<h3 id="配置后端存储到KS3"><a href="#配置后端存储到KS3" class="headerlink" title="配置后端存储到KS3"></a>配置后端存储到KS3</h3><p>在默认情况下，Harbor的镜像存储在本地磁盘/data/registry目录下。但是在生产环境中，出于高可用、高吞吐、安全可靠等因素，我们可能需要将镜像数据存储在KS3、Ceph等。</p>
<p>金山云提供了基于Docker registry v2封装了KS3驱动的官方镜像ksyun/registry:2。该镜像提供了Docker registry v2和KS3的完美对接，通过该镜像，用户可以很方便将镜像仓库数据存储到KS3上。</p>
<p>使用KS3作为Harbor镜像仓库的后端存储，你需要两步配置：<br>首先，修改harbor/docker-compose文件，修改registry模块，以支持KS3驱动的官方镜像。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">regsitry:</div><div class="line">	image: ksyun/registry:latest    <span class="comment"># 修改为支持KS3驱动的镜像</span></div><div class="line">    container_name: registry</div><div class="line">    restart: always</div><div class="line">    volumes:</div><div class="line">        <span class="comment"># 此处注释掉harbor默认挂在本地目录vlomues的存储方式</span></div><div class="line">        <span class="comment"># - /data/registry:/storage</span></div><div class="line">    	- ./common/config/registry/:/etc/registry/</div><div class="line">    environment:</div><div class="line">    	- GODEBUG=netdns=cgo</div><div class="line">    <span class="built_in">command</span>:</div><div class="line">    	[<span class="string">"serve"</span>, <span class="string">"/etc/registry/config.yml"</span>]</div><div class="line">    depends_on:</div><div class="line">    	- <span class="built_in">log</span></div><div class="line">    logging:</div><div class="line">    	driver: <span class="string">"syslog"</span></div><div class="line">    options:</div><div class="line">    	syslog-address: <span class="string">"tcp://127.0.0.1:1514"</span></div><div class="line">        tag: <span class="string">"registry"</span></div><div class="line">...</div></pre></td></tr></table></figure>
<p>其次，配置template/registry/config.yml文件，修改storage模块，为KS3的配置数据。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">storage:</div><div class="line">  cache: inmemory</div><div class="line">  ks3:</div><div class="line">    accesskey: <span class="string">"your ks3 accesskey"</span>          <span class="comment"># KS3的访问私钥</span></div><div class="line">    secretkey: <span class="string">"your ks3 secretkey"</span>          <span class="comment"># KS3的访问秘钥</span></div><div class="line">    internal: <span class="literal">false</span>                          <span class="comment"># 默认值false，是否使用内网加速，true代表使用内网加速，（高速，不计流量）</span></div><div class="line">    region： ks3-cn-beijing                  <span class="comment"># 区域设置</span></div><div class="line">    bucket : <span class="string">"your bucket name"</span>              <span class="comment"># KS3存储桶的名字</span></div><div class="line">    encrypt: <span class="literal">false</span>                           <span class="comment"># 默认值false，是否对镜像数据加密</span></div><div class="line">    secure: <span class="literal">false</span>                            <span class="comment"># 默认值false，是否使用https（ssl）</span></div><div class="line">    chunksize: 5242880                       <span class="comment"># 块大小</span></div><div class="line">    storage_page: /                          <span class="comment"># 存储路径</span></div></pre></td></tr></table></figure>
<p>更多KS3存储配置，参见<a href="https://github.com/softlns/distribution/blob/master/docs/storage-drivers/ks3.md" target="_blank" rel="external">Docker Registry KS3存储驱动配置</a>。</p>
<h3 id="HTTPS配置"><a href="#HTTPS配置" class="headerlink" title="HTTPS配置"></a>HTTPS配置</h3><h4 id="创建CA证书"><a href="#创建CA证书" class="headerlink" title="创建CA证书"></a>创建CA证书</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">openssl req \</div><div class="line">  -newkey rsa:4096 -nodes -sha256 -keyout ca.key \</div><div class="line">  -x509 -days 365 -out ca.crt</div></pre></td></tr></table></figure>
<h4 id="证书签名"><a href="#证书签名" class="headerlink" title="证书签名"></a>证书签名</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">openssl req \</div><div class="line">  -newkey rsa:4096 -nodes -sha256 -keyout yourdomain.com.key \</div><div class="line">  -out yourdomain.com.csr</div></pre></td></tr></table></figure>
<h4 id="初始化CA信息"><a href="#初始化CA信息" class="headerlink" title="初始化CA信息"></a>初始化CA信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mkdir demoCA</div><div class="line"><span class="built_in">cd</span> demoCA</div><div class="line">touch index.txt</div><div class="line"><span class="built_in">echo</span> <span class="string">'01'</span> &gt; serial</div><div class="line"><span class="built_in">cd</span> ..</div></pre></td></tr></table></figure>
<h4 id="配置Nginx"><a href="#配置Nginx" class="headerlink" title="配置Nginx"></a>配置Nginx</h4><ul>
<li><p>复制证书</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 复制证书</span></div><div class="line">cp registry.mritd.me.crt config/nginx/cert</div><div class="line">cp ca/registry.mritd.me.key config/nginx/cert</div><div class="line"><span class="comment"># 备份配置</span></div><div class="line">mv config/nginx/nginx.conf config/nginx/nginx.conf.bak</div><div class="line"><span class="comment"># 使用模板文件</span></div><div class="line">mv config/nginx/nginx.https.conf config/nginx/nginx.conf</div></pre></td></tr></table></figure>
</li>
<li><p>修改nginx.conf配置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> server &#123;</div><div class="line">  listen 443 ssl;</div><div class="line">  server_name harbordomain.com;</div><div class="line">  ...</div><div class="line">server &#123;</div><div class="line">  listen 80;</div><div class="line">  server_name harbordomain.com;</div><div class="line">  rewrite ^/(.*) https://<span class="variable">$server_name</span>:443/<span class="variable">$1</span> permanent;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="执行安装脚本并启动Harbor"><a href="#执行安装脚本并启动Harbor" class="headerlink" title="执行安装脚本并启动Harbor"></a>执行安装脚本并启动Harbor</h3><p>配置完成后，执行Harbor提供的安装脚本（install.sh），来生成私有配置，在线安装版本会到Docker Hub拉取镜像，并启动Harbor服务。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo ./install.sh</div></pre></td></tr></table></figure></p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ul>
<li><p>访问Harbor UI</p>
<p>  在浏览器中打开<a href="http://reg.yourdomain.com/" target="_blank" rel="external">http://reg.yourdomain.com/</a> ，以admin账号（初始账号/密码：admin/Harbor12345）登录，可以查看Harbor的控制面板。</p>
</li>
<li><p>测试docker client 登录、推拉镜像</p>
<p>  在控制面板（Harbor UI）中创建一个项目myproject，docker client登录认证，并测试推送私有镜像：</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ docker login reg.yourdomain.com</div><div class="line">$ docker push reg.yourdomain.com/myproject/myrepo:mytag</div></pre></td></tr></table></figure>
<h2 id="管理Harbor的生命周期"><a href="#管理Harbor的生命周期" class="headerlink" title="管理Harbor的生命周期"></a>管理Harbor的生命周期</h2><p>你可以通过docker-compose工具来管理Harbor的生命周期，常用命令如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 停止Harbor</span></div><div class="line">$ sudo docker-compose stop </div><div class="line">Stopping harbor_proxy_1 ... <span class="keyword">done</span></div><div class="line">Stopping harbor_ui_1 ... <span class="keyword">done</span></div><div class="line">Stopping harbor_registry_1 ... <span class="keyword">done</span></div><div class="line">Stopping harbor_mysql_1 ... <span class="keyword">done</span></div><div class="line">Stopping harbor_log_1 ... <span class="keyword">done</span></div><div class="line">Stopping harbor_jobservice_1 ... <span class="keyword">done</span></div><div class="line"><span class="comment"># 启动harbor</span></div><div class="line">$ sudo docker-compose start</div><div class="line">Starting harbor_log_1</div><div class="line">Starting harbor_mysql_1</div><div class="line">Starting harbor_registry_1</div><div class="line">Starting harbor_ui_1</div><div class="line">Starting harbor_proxy_1</div><div class="line">Starting harbor_jobservice_1</div><div class="line"><span class="comment"># 更新Harbor配置</span></div><div class="line">$ sudo docker-compose down</div><div class="line">$ vim harbor.cfg</div><div class="line">$ sudo install.sh</div></pre></td></tr></table></figure></p>
<p>关于docker-compose详见<a href="https://docs.docker.com/compose/reference/" target="_blank" rel="external">Docker Compose</a>文档 。</p>
<h2 id="More"><a href="#More" class="headerlink" title="More"></a>More</h2><p>KS3更多信息，参见 <a href="http://www.ksyun.com/proservice/storage_service" target="_blank" rel="external">http://www.ksyun.com/proservice/storage_service</a><br>Harbor更多信息，参见 <a href="http://vmware.github.io/harbor/" target="_blank" rel="external">http://vmware.github.io/harbor/</a><br>Registry更多信息，参见 <a href="https://docker.github.io/registry/" target="_blank" rel="external">https://docker.github.io/registry/</a><br>Docker更多信息，参见 <a href="https://docs.docker.com" target="_blank" rel="external">https://docs.docker.com</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Harbor 是 VMware 中国开发的一款 Docker Registry 工具，其主要致力于企业级的 Registry 管理，并提供了 LDAP 等高级权限认证功能。&lt;/p&gt;
&lt;p&gt;KS3（Kingsoft Standard Storage Service）是金山云为企业用户提供的无限制、多备份、分布式的低成本存储空间服务，解决存储扩容、数据可靠安全以及分布式访问等相关复杂问题。&lt;/p&gt;
&lt;p&gt;本文介绍了如何使用基于KS3存储搭建Harbor企业级的Registry镜像仓库管理。&lt;br&gt;
    
    </summary>
    
    
      <category term="KS3" scheme="https://softlns.github.io/tags/KS3/"/>
    
      <category term="Docker" scheme="https://softlns.github.io/tags/Docker/"/>
    
      <category term="Habor" scheme="https://softlns.github.io/tags/Habor/"/>
    
  </entry>
  
  <entry>
    <title>搭建Kubernetes1.4集群</title>
    <link href="https://softlns.github.io/2016/10/22/create-kubernetes-cluster/"/>
    <id>https://softlns.github.io/2016/10/22/create-kubernetes-cluster/</id>
    <published>2016-10-22T12:48:31.000Z</published>
    <updated>2016-12-05T09:53:10.033Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Kubernetes 1.4引入了kubeadm的部署机制，极大地简化了Kubernetes集群的构建，可以很方便地集成到自动化运维中（Terraform, Chef, Puppet等）。</p>
<p>kubeadm还处于alpha版本，替换之前kube-up.sh，用于集群的创建和节点的增加。<br><a id="more"></a></p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul>
<li>1、主机集群：一台以上物理机或是VM</li>
<li>2、硬件配置：1G以上内存</li>
<li>3、操作系统：ubuntu 16.04、CentOS7、HypriotOS v1.0.1</li>
<li>4、集群网络：集群所有主机都是连通的（公有或是私有网络）</li>
</ul>
<h2 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h2><h3 id="安装-kubelet-和-kubeadm"><a href="#安装-kubelet-和-kubeadm" class="headerlink" title="安装 kubelet 和 kubeadm"></a>安装 kubelet 和 kubeadm</h3><p>Kubernetes安装依赖于以下程序包，需要在每个主机（节点）上安装：</p>
<ul>
<li>docker：容器运行环境 </li>
<li>kubelet：Kubernetes最核心的组件，它运行在集群所有的节点上，并实际操作POD和容器</li>
<li>kubectl：交互命令行控制集群。通常在Master节点使用，也可在worker节点使用</li>
<li>kubeadm：交互命令行加载集群，用于集群的创建和节点的增加。</li>
</ul>
<h4 id="Ubuntu-Debian-HypriotOS系统"><a href="#Ubuntu-Debian-HypriotOS系统" class="headerlink" title="Ubuntu/Debian/HypriotOS系统"></a>Ubuntu/Debian/HypriotOS系统</h4><p>切换至root用户，普通用户执行<figure class="highlight plain"><figcaption><span>su -```切换至root用户，执行如下命令：</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">```bash</div><div class="line"># curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | apt-key add -</div><div class="line"># cat &lt;&lt;EOF &gt; /etc/apt/sources.list.d/kubernetes.list</div><div class="line">deb http://apt.kubernetes.io/ kubernetes-xenial main</div><div class="line">EOF</div><div class="line"># apt-get update</div><div class="line"># # Install docker if you don&apos;t have it already.</div><div class="line"># apt-get install -y docker.io</div><div class="line"># apt-get install -y kubelet kubeadm kubectl kubernetes-cni</div></pre></td></tr></table></figure></p>
<h4 id="CentOS7系统"><a href="#CentOS7系统" class="headerlink" title="CentOS7系统"></a>CentOS7系统</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo</span></div><div class="line">[kubernetes]</div><div class="line">name=Kubernetes</div><div class="line">baseurl=http://yum.kubernetes.io/repos/kubernetes-el7-x86_64</div><div class="line">enabled=1</div><div class="line">gpgcheck=1</div><div class="line">repo_gpgcheck=1</div><div class="line">gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg</div><div class="line">       https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg</div><div class="line">EOF</div><div class="line"><span class="comment"># setenforce 0</span></div><div class="line"><span class="comment"># yum install -y docker kubelet kubeadm kubectl kubernetes-cni</span></div><div class="line"><span class="comment"># systemctl enable docker &amp;&amp; systemctl start docker</span></div><div class="line"><span class="comment"># systemctl enable kubelet &amp;&amp; systemctl start kubelet</span></div></pre></td></tr></table></figure>
<p>Note：kubelet 每间隔数秒重启一次，等待接受当出现故障时来自kubeadm的处理响应。</p>
<h3 id="初始化Master节点"><a href="#初始化Master节点" class="headerlink" title="初始化Master节点"></a>初始化Master节点</h3><p>Master节点运行着“control plane”一组组件，“control plane”的组件主要包括etcd（集群的k-v数据库）和 API Server（提供和kubectl CLI交互），所有的组件都通过kubelet启动运行在pod中。</p>
<p>选择一台安装有kebelet和kubeadm的主机。执行以下命令：<br><figure class="highlight plain"><figcaption><span>kubeadm init```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">kubeadm init 命令会去安装集群数据库和“control panel”的组件。这个过程会去gcr.io拉取镜像，需要等待几分钟。拉取镜像如下：</div><div class="line">```bash</div><div class="line">gcr.io/google_containers/kube-controller-manager-amd64:v1.4.0</div><div class="line">gcr.io/google_containers/kube-apiserver-amd64:v1.4.0</div><div class="line">gcr.io/google_containers/etcd-amd64:2.2.5</div><div class="line">gcr.io/google_containers/pause-amd64:3.0</div><div class="line">gcr.io/google_containers/kube-scheduler-amd64:v1.4.0</div></pre></td></tr></table></figure></p>
<p>Master节点正确初始化后，会有类似这样的输出：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;master/tokens&gt; generated token: <span class="string">"f0c861.753c505740ecde4c"</span></div><div class="line">&lt;master/pki&gt; created keys and certificates <span class="keyword">in</span> <span class="string">"/etc/kubernetes/pki"</span></div><div class="line">&lt;util/kubeconfig&gt; created <span class="string">"/etc/kubernetes/kubelet.conf"</span></div><div class="line">&lt;util/kubeconfig&gt; created <span class="string">"/etc/kubernetes/admin.conf"</span></div><div class="line">&lt;master/apiclient&gt; created API client configuration</div><div class="line">&lt;master/apiclient&gt; created API client, waiting <span class="keyword">for</span> the control plane to become ready</div><div class="line">&lt;master/apiclient&gt; all control plane components are healthy after 61.346626 seconds</div><div class="line">&lt;master/apiclient&gt; waiting <span class="keyword">for</span> at least one node to register and become ready</div><div class="line">&lt;master/apiclient&gt; first node is ready after 4.506807 seconds</div><div class="line">&lt;master/discovery&gt; created essential addon: kube-discovery</div><div class="line">&lt;master/addons&gt; created essential addon: kube-proxy</div><div class="line">&lt;master/addons&gt; created essential addon: kube-dns</div><div class="line"></div><div class="line">Kubernetes master initialised successfully!</div><div class="line"></div><div class="line">You can connect any number of nodes by running:</div><div class="line"></div><div class="line">kubeadm join --token &lt;token&gt; &lt;master-ip&gt;</div></pre></td></tr></table></figure></p>
<p>出于安全考虑，默认情况下Master节点不会调度部署pods，也就是说Master节点不会作为Worker节点，如果你想搭建单机集群，让Master节点成为Worker节点，执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># kubectl taint nodes --all dedicated-</span></div><div class="line">node <span class="string">"test-01"</span> tainted</div><div class="line">taint key=<span class="string">"dedicated"</span> and effect=<span class="string">""</span> not found.</div><div class="line">taint key=<span class="string">"dedicated"</span> and effect=<span class="string">""</span> not found</div></pre></td></tr></table></figure>
<p>注：这条命令将会从任何节点上移除“dedicated”标记，包括Master节点，这意味着调度器可以在任何节点上调度部署pods。</p>
<h3 id="配置Pod网络"><a href="#配置Pod网络" class="headerlink" title="配置Pod网络"></a>配置Pod网络</h3><p>Kubernetes 1.2版本默认使用的是flannel网络，用于解决POD跨主机之间的通信。新版本未提供默认的网络插件，在部署应用集群之前，必须要配置POD网络。</p>
<p>未配置POD网络，默认的KUBE-DNS是无法启动的，通过下面的方法查看：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#查看系统Pod</span></div><div class="line"><span class="comment"># kubectl get pods --namespace=kube-system</span></div><div class="line"><span class="comment"># NAME                                           READY     STATUS    RESTARTS   AGE</span></div><div class="line"><span class="comment">#kube-dns-2247936740-90wib                      0/3       ContainerCreating   0          4m</span></div><div class="line"><span class="comment"># 查看POD日志</span></div><div class="line"><span class="comment"># kubectl describe pod kube-dns-2247936740-90wib --namespace=kube-system</span></div><div class="line"><span class="comment"># ...</span></div></pre></td></tr></table></figure></p>
<p>这里使用的是weave网络，也可以使用Calico或Cannal。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># kubectl apply -f https://git.io/weave-kube</span></div><div class="line">daemonset <span class="string">"weave-net"</span> created</div></pre></td></tr></table></figure>
<p>网络安装完成，通过下面的命令可以查看kube-dns已经启动<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># kubectl get pods --namespace=kube-system</span></div><div class="line"><span class="comment"># NAME                                           READY     STATUS    RESTARTS   AGE</span></div><div class="line"><span class="comment"># etcd-lain-virtual-machine                      1/1       Running   0          5m</span></div><div class="line"><span class="comment"># kube-apiserver-lain-virtual-machine            1/1       Running   0          5m</span></div><div class="line"><span class="comment"># kube-controller-manager-lain-virtual-machine   1/1       Running   0          5m</span></div><div class="line"><span class="comment"># kube-discovery-982812725-98ivv                 1/1       Running   0          5m</span></div><div class="line"><span class="comment"># kube-dns-2247936740-90wib                      3/3       Running   0          5m</span></div><div class="line"><span class="comment"># kube-proxy-amd64-pgj8g                         1/1       Running   0          5m</span></div><div class="line"><span class="comment"># kube-scheduler-lain-virtual-machine            1/1       Running   0          5m</span></div><div class="line"><span class="comment"># weave-net-bkady                                2/2       Running   0          5m</span></div><div class="line"></div><div class="line"><span class="comment"># 查看启动配置</span></div><div class="line"><span class="comment"># ps aux | grep kubelet</span></div><div class="line"></div><div class="line"><span class="comment"># 输出日志</span></div><div class="line"><span class="comment"># ... /usr/bin/kubelet --kubeconfig=/etc/kubernetes/kubelet.conf --require-kubeconfig=true --pod-manifest-path=/etc/kubernetes/manifests --allow-privileged=true --network-plugin=cni --cni-conf-dir=/etc/cni/net.d --cni-bin-dir=/opt/cni/bin --cluster-dns=100.64.0.10 --cluster-domain=cluster.local --v=4</span></div></pre></td></tr></table></figure></p>
<h3 id="添加Worker节点"><a href="#添加Worker节点" class="headerlink" title="添加Worker节点"></a>添加Worker节点</h3><p>通过<figure class="highlight plain"><figcaption><span>join --token <token> <master-ip>```命令可以添加任意多的节点到Kubernetes集群中。命令操作如下：</master-ip></token></span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">```bash</div><div class="line"># kubeadm join --token &lt;token&gt; &lt;master-ip&gt;</div><div class="line">&lt;util/tokens&gt; validating provided token</div><div class="line">&lt;node/discovery&gt; created cluster info discovery client, requesting info from &quot;http://138.68.156.129:9898/cluster-info/v1/?token-id=0f8588&quot;</div><div class="line">&lt;node/discovery&gt; cluster info object received, verifying signature using given token</div><div class="line">&lt;node/discovery&gt; cluster info signature and contents are valid, will use API endpoints [https://138.68.156.129:443]</div><div class="line">&lt;node/csr&gt; created API client to obtain unique certificate for this node, generating keys and certificate signing request</div><div class="line">&lt;node/csr&gt; received signed certificate from the API server, generating kubelet configuration</div><div class="line">&lt;util/kubeconfig&gt; created &quot;/etc/kubernetes/kubelet.conf&quot;</div><div class="line"></div><div class="line">Node join complete:</div><div class="line">* Certificate signing request sent to master and response</div><div class="line">  received.</div><div class="line">* Kubelet informed of new secure connection details.</div><div class="line"></div><div class="line">Run &apos;kubectl get nodes&apos; on the master to see this machine join.</div></pre></td></tr></table></figure></p>
<p>添加worker节点后，可以在Master节点通过<figure class="highlight plain"><figcaption><span>get nodes```查看集群里的机器。</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 从Master节点以外的机器控制集群</div><div class="line">如果你想在笔记本上通过kubectl来控制你的集群，只需要将Master节点上KubeConfig复制到你的笔记本即可，操作如下：</div><div class="line"></div><div class="line">```bash</div><div class="line"># scp root@&lt;master ip&gt;:/etc/kubernetes/admin.conf .</div><div class="line"># kubectl --kubeconfig ./admin.conf get nodes</div></pre></td></tr></table></figure></p>
<h3 id="安装Demo应用"><a href="#安装Demo应用" class="headerlink" title="安装Demo应用"></a>安装Demo应用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># kubectl create namespace sock-shop</span></div><div class="line"><span class="comment"># kubectl apply -n sock-shop -f "https://github.com/microservices-demo/microservices-demo/blob/master/deploy/kubernetes/complete-demo.yaml?raw=true"</span></div></pre></td></tr></table></figure>
<h3 id="Tear-down"><a href="#Tear-down" class="headerlink" title="Tear down"></a>Tear down</h3><ul>
<li>uninstall 一个app，在Master节点执行<figure class="highlight plain"><figcaption><span>delete namespace sock-shop```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- undo kubeadm的操作，重置本地状态:</div><div class="line">```bash </div><div class="line">systemctl stop kubelet;</div><div class="line">docker rm -f -v $(docker ps -q);</div><div class="line">find /var/lib/kubelet | xargs -n 1 findmnt -n -t tmpfs -o TARGET -T | uniq | xargs -r umount -v;</div><div class="line">rm -r -f /etc/kubernetes /var/lib/kubelet /var/lib/etcd;</div></pre></td></tr></table></figure></li>
</ul>
<h2 id="More"><a href="#More" class="headerlink" title="More"></a>More</h2><ul>
<li>学习Kubeadm的高级用法 <a href="http://kubernetes.io/docs/admin/kubeadm/" target="_blank" rel="external">http://kubernetes.io/docs/admin/kubeadm/</a></li>
<li>学习更多Kubernetes理念和kubctl的用法： <a href="http://kubernetes.io/docs/user-guide/walkthrough/" target="_blank" rel="external">http://kubernetes.io/docs/user-guide/walkthrough/</a></li>
<li>学习其他组件（包括日志、监控、网络策略、可视化控制等），参见: <a href="http://kubernetes.io/docs/admin/addons" target="_blank" rel="external">http://kubernetes.io/docs/admin/addons</a>.</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Kubernetes 1.4引入了kubeadm的部署机制，极大地简化了Kubernetes集群的构建，可以很方便地集成到自动化运维中（Terraform, Chef, Puppet等）。&lt;/p&gt;
&lt;p&gt;kubeadm还处于alpha版本，替换之前kube-up.sh，用于集群的创建和节点的增加。&lt;br&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="https://softlns.github.io/tags/Docker/"/>
    
      <category term="Kubernetes" scheme="https://softlns.github.io/tags/Kubernetes/"/>
    
      <category term="Cluster" scheme="https://softlns.github.io/tags/Cluster/"/>
    
  </entry>
  
  <entry>
    <title>Gevent简明教程</title>
    <link href="https://softlns.github.io/2015/11/28/python-gevent/"/>
    <id>https://softlns.github.io/2015/11/28/python-gevent/</id>
    <published>2015-11-28T12:42:34.000Z</published>
    <updated>2016-12-05T09:46:53.259Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前述"><a href="#前述" class="headerlink" title="前述"></a>前述</h2><h3 id="进程-线程-协程-异步"><a href="#进程-线程-协程-异步" class="headerlink" title="进程 线程 协程 异步"></a>进程 线程 协程 异步</h3><p>并发编程（不是并行）目前有四种方式：多进程、多线程、协程和异步。</p>
<ul>
<li>多进程编程在python中有类似C的os.fork,更高层封装的有multiprocessing标准库</li>
<li>多线程编程python中有Thread和threading</li>
<li>异步编程在linux下主+要有三种实现select，poll，epoll</li>
<li>协程在python中通常会说到yield，关于协程的库主要有greenlet,stackless,gevent,eventlet等实现。</li>
</ul>
<a id="more"></a>
<h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><ul>
<li>不共享任何状态</li>
<li>调度由操作系统完成</li>
<li>有独立的内存空间（上下文切换的时候需要保存栈、cpu寄存器、虚拟内存、以及打开的相关句柄等信息，开销大）</li>
<li>通讯主要通过信号传递的方式来实现（实现方式有多种，信号量、管道、事件等，通讯都需要过内核，效率低）</li>
</ul>
<h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><ul>
<li>共享变量（解决了通讯麻烦的问题，但是对于变量的访问需要加锁）</li>
<li>调度由操作系统完成（由于共享内存，上下文切换变得高效）</li>
<li>一个进程可以有多个线程，每个线程会共享父进程的资源（创建线程开销占用比进程小很多，可创建的数量也会很多）</li>
<li>通讯除了可使用进程间通讯的方式，还可以通过共享内存的方式进行通信（通过共享内存通信比通过内核要快很多）</li>
</ul>
<h4 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h4><ul>
<li>调度完全由用户控制</li>
<li>一个线程（进程）可以有多个协程</li>
<li>每个线程（进程）循环按照指定的任务清单顺序完成不同的任务（当任务被堵塞时，执行下一个任务；当恢复时，再回来执行这个任务；任务间切换只需要保存任务的上下文，没有内核的开销，可以不加锁的访问全局变量）</li>
<li>协程需要保证是非堵塞的且没有相互依赖</li>
<li>协程基本上不能同步通讯，多采用异步的消息通讯，效率比较高</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>进程拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程由操作系统调度</li>
<li>线程拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度(标准线程是的)</li>
<li>协程和线程一样共享堆，不共享栈，协程由程序员在协程的代码里显示调度</li>
</ul>
<h3 id="聊聊协程"><a href="#聊聊协程" class="headerlink" title="聊聊协程"></a>聊聊协程</h3><p>协程，又称微线程，纤程。<br>Python的线程并不是标准线程，是系统级进程，线程间上下文切换有开销，而且Python在执行多线程时默认加了一个全局解释器锁（GIL），因此Python的多线程其实是串行的，所以并不能利用多核的优势，也就是说一个进程内的多个线程只能使用一个CPU。</p>
<pre><code>def coroutine(func):
    def ret():
        f = func()
        f.next()
        return f
    return ret


@coroutine
def consumer():
    print &quot;Wait to getting a task&quot;
    while True:
        n = (yield)
        print &quot;Got %s&quot;,n


import time
def producer():
    c = consumer()
    task_id = 0
    while True:
        time.sleep(1)
        print &quot;Send a task to consumer&quot; % task_id
        c.send(&quot;task %s&quot; % task_id)

if __name__ == &quot;__main__&quot;:
    producer()
</code></pre><p>  结果：</p>
<pre><code>Wait to getting a task
Send a task 0 to consumer
Got task 0
Send a task 1 to consumer
Got task 1
Send a task 2 to consumer
Got task 2
...
</code></pre><p> 传统的生产者-消费者模型是一个线程写消息，一个线程取消息，通过锁机制控制队列和等待，但容易死锁。<br>如果改用协程，生产者生产消息后，直接通过yield跳转到消费者开始执行，待消费者执行完毕后，切换回生产者继续生产，效率极高。</p>
<h2 id="Gevent"><a href="#Gevent" class="headerlink" title="Gevent"></a>Gevent</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>gevent是基于协程的Python网络库。特点：</p>
<ul>
<li>基于libev的快速事件循环(Linux上epoll，FreeBSD上kqueue）。</li>
<li>基于greenlet的轻量级执行单元。</li>
<li>API的概念和Python标准库一致(如事件，队列)。</li>
<li>可以配合socket，ssl模块使用。</li>
<li>能够使用标准库和第三方模块创建标准的阻塞套接字(gevent.monkey)。</li>
<li>默认通过线程池进行DNS查询,也可通过c-are(通过GEVENT_RESOLVER=ares环境变量开启）。</li>
<li>TCP/UDP/HTTP服务器</li>
<li>子进程支持（通过gevent.subprocess）</li>
<li>线程池</li>
</ul>
<h3 id="安装和依赖"><a href="#安装和依赖" class="headerlink" title="安装和依赖"></a>安装和依赖</h3><p>依赖于greenlet library<br>支持python 2.6+ 、3.3+</p>
<h3 id="核心部分"><a href="#核心部分" class="headerlink" title="核心部分"></a>核心部分</h3><ul>
<li>Greenlets</li>
<li>同步和异步执行</li>
<li>确定性</li>
<li>创建Greenlets</li>
<li>Greenlet状态</li>
<li>程序停止</li>
<li>超时</li>
<li>猴子补丁</li>
</ul>
<p>####Greenlets<br>gevent中的主要模式, 它是以C扩展模块形式接入Python的轻量级协程。 全部运行在主程序操作系统进程的内部，但它们被程序员协作式地调度。</p>
<blockquote>
<p>在任何时刻，只有一个协程在运行。</p>
</blockquote>
<p>区别于multiprocessing、threading等提供真正并行构造的库， 这些库轮转使用操作系统调度的进程和线程，是真正的并行。</p>
<h4 id="同步和异步执行"><a href="#同步和异步执行" class="headerlink" title="同步和异步执行"></a>同步和异步执行</h4><p>并发的核心思想在于，大的任务可以分解成一系列的子任务，后者可以被调度成 同时执行或异步执行，而不是一次一个地或者同步地执行。两个子任务之间的 切换也就是上下文切换。</p>
<p>在gevent里面，上下文切换是通过yielding来完成的.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> gevent</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">'Running in foo'</span>)</div><div class="line">    gevent.sleep(<span class="number">0</span>)</div><div class="line">    print(<span class="string">'Explicit context switch to foo again'</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">'Explicit context to bar'</span>)</div><div class="line">    gevent.sleep(<span class="number">0</span>)</div><div class="line">    print(<span class="string">'Implicit context switch back to bar'</span>)</div><div class="line"></div><div class="line">gevent.joinall([</div><div class="line">    gevent.spawn(foo),</div><div class="line">    gevent.spawn(bar),</div><div class="line">])</div></pre></td></tr></table></figure></p>
<p>执行结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Running <span class="keyword">in</span> foo</div><div class="line">Explicit context to bar</div><div class="line">Explicit context switch to foo again</div><div class="line">Implicit context switch back to bar</div></pre></td></tr></table></figure></p>
<p>代码执行过程：</p>
<p><img src="http://xlambda.com/gevent-tutorial/flow.gif" alt="Alt text"></p>
<p>网络延迟或IO阻塞隐式交出greenlet上下文的执行权。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">import</span> gevent</div><div class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> select</div><div class="line"></div><div class="line">start = time.time()</div><div class="line">tic = <span class="keyword">lambda</span>: <span class="string">'at %1.1f seconds'</span> % (time.time() - start)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">gr1</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">'Started Polling: %s'</span> % tic())</div><div class="line">    select.select([], [], [], <span class="number">1</span>)</div><div class="line">    print(<span class="string">'Ended Polling: %s'</span> % tic())</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">gr2</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">'Started Polling: %s'</span> % tic())</div><div class="line">    select.select([], [], [], <span class="number">2</span>)</div><div class="line">    print(<span class="string">'Ended Polling: %s'</span> % tic())</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">gr3</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">"Hey lets do some stuff while the greenlets poll, %s"</span> % tic())</div><div class="line">    gevent.sleep(<span class="number">1</span>)</div><div class="line"></div><div class="line">gevent.joinall([</div><div class="line">    gevent.spawn(gr1),</div><div class="line">    gevent.spawn(gr2),</div><div class="line">    gevent.spawn(gr3),</div><div class="line">])</div></pre></td></tr></table></figure></p>
<p>执行结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Started Polling: at 0.0 seconds</div><div class="line">Started Polling: at 0.0 seconds</div><div class="line">Hey lets <span class="keyword">do</span> some stuff <span class="keyword">while</span> the greenlets poll, at 0.0 seconds</div><div class="line">Ended Polling: at 1.0 seconds</div><div class="line">Ended Polling: at 2.0 seconds</div></pre></td></tr></table></figure></p>
<p>同步vs异步<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> gevent</div><div class="line"><span class="keyword">import</span> random</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(pid)</span>:</span></div><div class="line">    gevent.sleep(random.randint(<span class="number">0</span>,<span class="number">2</span>)*<span class="number">0.001</span>)</div><div class="line">    print(<span class="string">'Task %s done'</span> % pid)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">synchronous</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">5</span>):</div><div class="line">        task(i)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">asynchronous</span><span class="params">()</span>:</span></div><div class="line">    threads = [gevent.spawn(task, i) <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">5</span>)]</div><div class="line">    gevent.joinall(threads)</div><div class="line"></div><div class="line">    print(<span class="string">'Synchronous:'</span>)</div><div class="line">    synchronous()</div><div class="line"></div><div class="line">    print(<span class="string">'Asynchronous:'</span>)</div><div class="line">    asynchronous()</div></pre></td></tr></table></figure></p>
<p>执行结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Synchronous:</div><div class="line">Task 0 <span class="keyword">done</span></div><div class="line">Task 1 <span class="keyword">done</span></div><div class="line">Task 2 <span class="keyword">done</span></div><div class="line">Task 3 <span class="keyword">done</span></div><div class="line">Task 4 <span class="keyword">done</span></div><div class="line">Asynchronous:</div><div class="line">Task 2 <span class="keyword">done</span></div><div class="line">Task 0 <span class="keyword">done</span></div><div class="line">Task 1 <span class="keyword">done</span></div><div class="line">Task 3 <span class="keyword">done</span></div><div class="line">Task 4 <span class="keyword">done</span></div></pre></td></tr></table></figure></p>
<h4 id="确定性"><a href="#确定性" class="headerlink" title="确定性"></a>确定性</h4><p>greenlet具有确定性。在相同配置相同输入的情况下，它们总是会产生相同的输出。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">echo</span><span class="params">(i)</span>:</span></div><div class="line">    time.sleep(<span class="number">0.001</span>)</div><div class="line">    <span class="keyword">return</span> i</div><div class="line"></div><div class="line"><span class="comment"># Non Deterministic Process Pool</span></div><div class="line"><span class="keyword">from</span> multiprocessing.pool <span class="keyword">import</span> Pool</div><div class="line"></div><div class="line">p = Pool(<span class="number">10</span>)</div><div class="line">run1 = [a <span class="keyword">for</span> a <span class="keyword">in</span> p.imap_unordered(echo, xrange(<span class="number">10</span>))]</div><div class="line">run2 = [a <span class="keyword">for</span> a <span class="keyword">in</span> p.imap_unordered(echo, xrange(<span class="number">10</span>))]</div><div class="line">run3 = [a <span class="keyword">for</span> a <span class="keyword">in</span> p.imap_unordered(echo, xrange(<span class="number">10</span>))]</div><div class="line">run4 = [a <span class="keyword">for</span> a <span class="keyword">in</span> p.imap_unordered(echo, xrange(<span class="number">10</span>))]</div><div class="line"></div><div class="line">print(run1 == run2 == run3 == run4)</div><div class="line"></div><div class="line"><span class="comment"># Deterministic Gevent Pool</span></div><div class="line"><span class="keyword">from</span> gevent.pool <span class="keyword">import</span> Pool</div><div class="line"></div><div class="line">p = Pool(<span class="number">10</span>)</div><div class="line">run1 = [a <span class="keyword">for</span> a <span class="keyword">in</span> p.imap_unordered(echo, xrange(<span class="number">10</span>))]</div><div class="line">run2 = [a <span class="keyword">for</span> a <span class="keyword">in</span> p.imap_unordered(echo, xrange(<span class="number">10</span>))]</div><div class="line">run3 = [a <span class="keyword">for</span> a <span class="keyword">in</span> p.imap_unordered(echo, xrange(<span class="number">10</span>))]</div><div class="line">run4 = [a <span class="keyword">for</span> a <span class="keyword">in</span> p.imap_unordered(echo, xrange(<span class="number">10</span>))]</div><div class="line"></div><div class="line">print(run1 == run2 == run3 == run4)</div></pre></td></tr></table></figure>
<p>执行结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">False</div><div class="line">True</div></pre></td></tr></table></figure></p>
<p>即使gevent通常带有确定性，当开始与如socket或文件等外部服务交互时， 不确定性也可能溜进你的程序中。因此尽管gevent线程是一种“确定的并发”形式， 使用它仍然可能会遇到像使用POSIX线程或进程时遇到的那些问题。</p>
<p>涉及并发长期存在的问题就是竞争条件(race condition)(当两个并发线程/进程都依赖于某个共享资源同时都尝试去修改它的时候， 就会出现竞争条件),这会导致资源修改的结果状态依赖于时间和执行顺序。 这个问题，会导致整个程序行为变得不确定。</p>
<p>解决办法: 始终避免所有全局的状态.</p>
<h4 id="创建Greenlets"><a href="#创建Greenlets" class="headerlink" title="创建Greenlets"></a>创建Greenlets</h4><p>gevent对Greenlet初始化提供了一些封装.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> gevent</div><div class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> Greenlet</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(message, n)</span>:</span></div><div class="line">    gevent.sleep(n)</div><div class="line">    print(message)</div><div class="line"></div><div class="line">    thread1 = Greenlet.spawn(foo, <span class="string">"Hello"</span>, <span class="number">1</span>)</div><div class="line">    thread2 = gevent.spawn(foo, <span class="string">"I live!"</span>, <span class="number">2</span>)</div><div class="line">    thread3 = gevent.spawn(<span class="keyword">lambda</span> x: (x+<span class="number">1</span>), <span class="number">2</span>)</div><div class="line">    threads = [thread1, thread2, thread3]</div><div class="line">    gevent.joinall(threads)</div></pre></td></tr></table></figure></p>
<p>执行结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Hello</div><div class="line">I live!</div></pre></td></tr></table></figure></p>
<p>除使用基本的Greenlet类之外，你也可以子类化Greenlet类，重载它的_run方法。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> gevent</div><div class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> Greenlet</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyGreenlet</span><span class="params">(Greenlet)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, message, n)</span>:</span></div><div class="line">        Greenlet.__init__(self)</div><div class="line">        self.message = message</div><div class="line">        self.n = n</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_run</span><span class="params">(self)</span>:</span></div><div class="line">        print(self.message)</div><div class="line">        gevent.sleep(self.n)</div><div class="line"></div><div class="line">g = MyGreenlet(<span class="string">"Hi there!"</span>, <span class="number">3</span>)</div><div class="line">g.start()</div><div class="line">g.join()</div></pre></td></tr></table></figure></p>
<p>执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hi there!</div></pre></td></tr></table></figure></p>
<h4 id="Greenlet状态"><a href="#Greenlet状态" class="headerlink" title="Greenlet状态"></a>Greenlet状态</h4><p>greenlet的状态通常是一个依赖于时间的参数：</p>
<ul>
<li>started – Boolean, 指示此Greenlet是否已经启动</li>
<li>ready() – Boolean, 指示此Greenlet是否已经停止</li>
<li>successful() – Boolean, 指示此Greenlet是否已经停止而且没抛异常</li>
<li>value – 任意值, 此Greenlet代码返回的值</li>
<li>exception – 异常, 此Greenlet内抛出的未捕获异常</li>
</ul>
<h4 id="程序停止"><a href="#程序停止" class="headerlink" title="程序停止"></a>程序停止</h4><p>程序<br>当主程序(main program)收到一个SIGQUIT信号时，不能成功做yield操作的 Greenlet可能会令意外地挂起程序的执行。这导致了所谓的僵尸进程， 它需要在Python解释器之外被kill掉。</p>
<p>通用的处理模式就是在主程序中监听SIGQUIT信号，调用gevent.shutdown退出程序。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> gevent</div><div class="line"><span class="keyword">import</span> signal</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_forever</span><span class="params">()</span>:</span></div><div class="line">    gevent.sleep(<span class="number">1000</span>)</div><div class="line"></div><div class="line">    <span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">        gevent.signal(signal.SIGQUIT, gevent.shutdown)</div><div class="line">        thread = gevent.spawn(run_forever)</div><div class="line">        thread.join()</div></pre></td></tr></table></figure></p>
<h4 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h4><p>通过超时可以对代码块儿或一个Greenlet的运行时间进行约束。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> gevent</div><div class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> Timeout</div><div class="line"></div><div class="line">seconds = <span class="number">10</span></div><div class="line"></div><div class="line">timeout = Timeout(seconds)</div><div class="line">timeout.start()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">wait</span><span class="params">()</span>:</span></div><div class="line">    gevent.sleep(<span class="number">10</span>)</div><div class="line"></div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        gevent.spawn(wait).join()</div><div class="line">    <span class="keyword">except</span> Timeout:</div><div class="line">        print(<span class="string">'Could not complete'</span>)</div></pre></td></tr></table></figure></p>
<p>超时类<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> gevent</div><div class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> Timeout</div><div class="line"></div><div class="line">time_to_wait = <span class="number">5</span> <span class="comment"># seconds</span></div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TooLong</span><span class="params">(Exception)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line"></div><div class="line">    <span class="keyword">with</span> Timeout(time_to_wait, TooLong):</div><div class="line">        gevent.sleep(<span class="number">10</span>)</div></pre></td></tr></table></figure></p>
<p>另外，对各种Greenlet和数据结构相关的调用，gevent也提供了超时参数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> gevent</div><div class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> Timeout</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">wait</span><span class="params">()</span>:</span></div><div class="line">    gevent.sleep(<span class="number">2</span>)</div><div class="line"></div><div class="line">timer = Timeout(<span class="number">1</span>).start()</div><div class="line">thread1 = gevent.spawn(wait)</div><div class="line"></div><div class="line"><span class="keyword">try</span>:</div><div class="line">    thread1.join(timeout=timer)</div><div class="line"><span class="keyword">except</span> Timeout:</div><div class="line">    print(<span class="string">'Thread 1 timed out'</span>)</div><div class="line"></div><div class="line"><span class="comment"># --</span></div><div class="line"></div><div class="line">timer = Timeout.start_new(<span class="number">1</span>)</div><div class="line">thread2 = gevent.spawn(wait)</div><div class="line"></div><div class="line"><span class="keyword">try</span>:</div><div class="line">    thread2.get(timeout=timer)</div><div class="line"><span class="keyword">except</span> Timeout:</div><div class="line">    print(<span class="string">'Thread 2 timed out'</span>)</div><div class="line"></div><div class="line"><span class="comment"># --</span></div><div class="line"></div><div class="line"><span class="keyword">try</span>:</div><div class="line">    gevent.with_timeout(<span class="number">1</span>, wait)</div><div class="line"><span class="keyword">except</span> Timeout:</div><div class="line">    print(<span class="string">'Thread 3 timed out'</span>)</div></pre></td></tr></table></figure></p>
<p>执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Thread 1 timed out</div><div class="line">Thread 2 timed out</div><div class="line">Thread 3 timed out</div></pre></td></tr></table></figure></p>
<h4 id="猴子补丁-Monkey-patching"><a href="#猴子补丁-Monkey-patching" class="headerlink" title="猴子补丁(Monkey patching)"></a>猴子补丁(Monkey patching)</h4><p>gevent的死角.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> socket</div><div class="line">print(socket.socket)</div><div class="line"></div><div class="line">print(<span class="string">"After monkey patch"</span>)</div><div class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey</div><div class="line">monkey.patch_socket()</div><div class="line">print(socket.socket)</div><div class="line"></div><div class="line"><span class="keyword">import</span> select</div><div class="line">print(select.select)</div><div class="line">monkey.patch_select()</div><div class="line">print(<span class="string">"After monkey patch"</span>)</div><div class="line">print(select.select)</div></pre></td></tr></table></figure></p>
<p>执行结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class <span class="string">'socket.socket'</span></div><div class="line">After monkey patch</div><div class="line">class <span class="string">'gevent.socket.socket'</span></div><div class="line"></div><div class="line">built-in <span class="keyword">function</span> select</div><div class="line">After monkey patch</div><div class="line"><span class="keyword">function</span> select at 0x1924de8</div></pre></td></tr></table></figure></p>
<p>Python的运行环境允许我们在运行时修改大部分的对象，包括模块，类甚至函数。 这是个一般说来令人惊奇的坏主意，因为它创造了“隐式的副作用”，如果出现问题 它很多时候是极难调试的。虽然如此，在极端情况下当一个库需要修改Python本身 的基础行为的时候，猴子补丁就派上用场了。在这种情况下，gevent能够修改标准库里面大部分的阻塞式系统调用，包括socket、ssl、threading和 select等模块，而变为协作式运行。</p>
<p>例如，Redis的python绑定一般使用常规的tcp socket来与redis-server实例通信。 通过简单地调用gevent.monkey.patch_all()，可以使得redis的绑定协作式的调度 请求，与gevent栈的其它部分一起工作。</p>
<p>这让我们可以将一般不能与gevent共同工作的库结合起来，而不用写哪怕一行代码。 虽然猴子补丁仍然是邪恶的(evil)，但在这种情况下它是“有用的邪恶(useful evil)”。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul>
<li>事件</li>
<li>队列</li>
<li>组和池</li>
<li>锁和信号量</li>
<li>线程局部变量</li>
<li>子进程</li>
<li>Actors<h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4>事件(event)是一个在Greenlet之间异步通信的形式。<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> gevent</div><div class="line"><span class="keyword">from</span> gevent.event <span class="keyword">import</span> Event</div><div class="line">	</div><div class="line">evt = Event()</div><div class="line">	</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">setter</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">'A: Hey wait for me, I have to do something'</span>)</div><div class="line">    gevent.sleep(<span class="number">3</span>)</div><div class="line">    print(<span class="string">"Ok, I'm done"</span>)</div><div class="line">    evt.set()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">waiter</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">"I'll wait for you"</span>)</div><div class="line">    evt.wait()  <span class="comment"># blocking</span></div><div class="line">    print(<span class="string">"It's about time"</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    gevent.joinall([</div><div class="line">        gevent.spawn(setter),</div><div class="line">        gevent.spawn(waiter),</div><div class="line">        gevent.spawn(waiter),</div><div class="line">        gevent.spawn(waiter)</div><div class="line">    ])</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>: </div><div class="line">    main()</div></pre></td></tr></table></figure>
</li>
</ul>
<p>执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">A: Hey wait for me, I have to do something</div><div class="line">I&apos;ll wait for you</div><div class="line">I&apos;ll wait for you</div><div class="line">I&apos;ll wait for you</div><div class="line">Ok, I&apos;m done</div><div class="line">It&apos;s about time</div><div class="line">It&apos;s about time</div><div class="line">It&apos;s about time</div></pre></td></tr></table></figure></p>
<p>事件对象的一个扩展是AsyncResult，它允许你在唤醒调用上附加一个值。 它有时也被称作是future或defered，因为它持有一个指向将来任意时间可设置为任何值的引用。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> gevent</div><div class="line"><span class="keyword">from</span> gevent.event <span class="keyword">import</span> AsyncResult</div><div class="line">a = AsyncResult()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">setter</span><span class="params">()</span>:</span></div><div class="line">    gevent.sleep(<span class="number">3</span>)</div><div class="line">    a.set(<span class="string">'Hello!'</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">waiter</span><span class="params">()</span>:</span></div><div class="line">    print(a.get())</div><div class="line"></div><div class="line">gevent.joinall([</div><div class="line">    gevent.spawn(setter),</div><div class="line">    gevent.spawn(waiter),</div><div class="line">])</div></pre></td></tr></table></figure></p>
<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>队列是一个排序的数据集合，它有常见的put / get操作， 但是它是以在Greenlet之间可以安全操作的方式来实现的。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> gevent</div><div class="line"><span class="keyword">from</span> gevent.queue <span class="keyword">import</span> Queue</div><div class="line"></div><div class="line">tasks = Queue()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(n)</span>:</span></div><div class="line">    <span class="keyword">while</span> <span class="keyword">not</span> tasks.empty():</div><div class="line">        task = tasks.get()</div><div class="line">        print(<span class="string">'Worker %s got task %s'</span> % (n, task))</div><div class="line">        gevent.sleep(<span class="number">0</span>)</div><div class="line">    print(<span class="string">'Quitting time!'</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">boss</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>,<span class="number">10</span>):</div><div class="line">        tasks.put_nowait(i)</div><div class="line"></div><div class="line">gevent.spawn(boss).join()</div><div class="line"></div><div class="line">gevent.joinall([</div><div class="line">    gevent.spawn(worker, <span class="string">'steve'</span>),</div><div class="line">    gevent.spawn(worker, <span class="string">'john'</span>),</div><div class="line">    gevent.spawn(worker, <span class="string">'nancy'</span>),</div><div class="line">])</div></pre></td></tr></table></figure></p>
<p>执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Worker steve got task 1</div><div class="line">Worker john got task 2</div><div class="line">Worker nancy got task 3</div><div class="line">Worker steve got task 4</div><div class="line">Worker john got task 5</div><div class="line">Worker nancy got task 6</div><div class="line">Worker steve got task 7</div><div class="line">Worker john got task 8</div><div class="line">Worker nancy got task 9</div><div class="line">Quitting time!</div><div class="line">Quitting time!</div><div class="line">Quitting time!</div></pre></td></tr></table></figure></p>
<p>put和get操作都是阻塞的，put_nowait和get_nowait不会阻塞， 然而在操作不能完成时抛出gevent.queue.Empty或gevent.queue.Full异常。</p>
<h4 id="组和池"><a href="#组和池" class="headerlink" title="组和池"></a>组和池</h4><p>组(group)是一个运行中greenlet集合，集合中的greenlet像一个组一样会被共同管理和调度。 它也兼饰了像Python的multiprocessing库那样的平行调度器的角色，主要用在在管理异步任务的时候进行分组。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> gevent</div><div class="line"><span class="keyword">from</span> gevent.pool <span class="keyword">import</span> Group</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">talk</span><span class="params">(msg)</span>:</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">2</span>):</div><div class="line">        print(msg)</div><div class="line"></div><div class="line">g1 = gevent.spawn(talk, <span class="string">'bar'</span>)</div><div class="line">g2 = gevent.spawn(talk, <span class="string">'foo'</span>)</div><div class="line">g3 = gevent.spawn(talk, <span class="string">'fizz'</span>)</div><div class="line"></div><div class="line">group = Group()</div><div class="line">group.add(g1)</div><div class="line">group.add(g2)</div><div class="line">group.join()</div><div class="line"></div><div class="line">group.add(g3)</div><div class="line">group.join()</div></pre></td></tr></table></figure></p>
<p>执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">bar</div><div class="line">bar</div><div class="line">foo</div><div class="line">foo</div><div class="line">fizz</div><div class="line">fizz</div></pre></td></tr></table></figure></p>
<p>池(pool)是一个为处理数量变化并且需要限制并发的greenlet而设计的结构。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> gevent</div><div class="line"><span class="keyword">from</span> gevent.pool <span class="keyword">import</span> Pool</div><div class="line"></div><div class="line">pool = Pool(<span class="number">2</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_from</span><span class="params">(n)</span>:</span></div><div class="line">    print(<span class="string">'Size of pool %s'</span> % len(pool))</div><div class="line"></div><div class="line">    pool.map(hello_from, xrange(<span class="number">3</span>))</div></pre></td></tr></table></figure></p>
<p>执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Size of pool 2</div><div class="line">Size of pool 2</div><div class="line">Size of pool 1</div></pre></td></tr></table></figure></p>
<p>构造一个socket池的类，在各个socket上轮询。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> gevent.pool <span class="keyword">import</span> Pool</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SocketPool</span><span class="params">(object)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.pool = Pool(<span class="number">10</span>)</div><div class="line">        self.pool.start()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">listen</span><span class="params">(self, socket)</span>:</span></div><div class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">            socket.recv()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_handler</span><span class="params">(self, socket)</span>:</span></div><div class="line">        <span class="keyword">if</span> self.pool.full():</div><div class="line">            <span class="keyword">raise</span> Exception(<span class="string">"At maximum pool size"</span>)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            self.pool.spawn(self.listen, socket)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shutdown</span><span class="params">(self)</span>:</span></div><div class="line">        self.pool.kill()</div></pre></td></tr></table></figure></p>
<h4 id="锁和信号量"><a href="#锁和信号量" class="headerlink" title="锁和信号量"></a>锁和信号量</h4><p>信号量是一个允许greenlet相互合作，限制并发访问或运行的低层次的同步原语。 信号量有两个方法，acquire和release。在信号量是否已经被 acquire或release，和拥有资源的数量之间不同，被称为此信号量的范围 (the bound of the semaphore)。如果一个信号量的范围已经降低到0，它会 阻塞acquire操作直到另一个已经获得信号量的greenlet作出释放。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> sleep</div><div class="line"><span class="keyword">from</span> gevent.pool <span class="keyword">import</span> Pool</div><div class="line"><span class="keyword">from</span> gevent.coros <span class="keyword">import</span> BoundedSemaphore</div><div class="line"></div><div class="line">sem = BoundedSemaphore(<span class="number">2</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker1</span><span class="params">(n)</span>:</span></div><div class="line">    sem.acquire()</div><div class="line">    print(<span class="string">'Worker %i acquired semaphore'</span> % n)</div><div class="line">    sleep(<span class="number">0</span>)</div><div class="line">    sem.release()</div><div class="line">    print(<span class="string">'Worker %i released semaphore'</span> % n)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker2</span><span class="params">(n)</span>:</span></div><div class="line">    <span class="keyword">with</span> sem:</div><div class="line">        print(<span class="string">'Worker %i acquired semaphore'</span> % n)</div><div class="line">        sleep(<span class="number">0</span>)</div><div class="line">    print(<span class="string">'Worker %i released semaphore'</span> % n)</div><div class="line"></div><div class="line">pool = Pool()</div><div class="line">pool.map(worker1, xrange(<span class="number">0</span>,<span class="number">2</span>))</div></pre></td></tr></table></figure></p>
<p>执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Worker 0 acquired semaphore</div><div class="line">Worker 1 acquired semaphore</div><div class="line">Worker 0 released semaphore</div><div class="line">Worker 1 released semaphore</div></pre></td></tr></table></figure></p>
<p>锁(lock)是范围为1的信号量。它向单个greenlet提供了互斥访问。 信号量和锁常被用来保证资源只在程序上下文被单次使用。</p>
<h4 id="线程局部变量"><a href="#线程局部变量" class="headerlink" title="线程局部变量"></a>线程局部变量</h4><p>Gevent允许程序员指定局部于greenlet上下文的数据。 在内部，它被实现为以greenlet的getcurrent()为键， 在一个私有命名空间寻址的全局查找。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> gevent</div><div class="line"><span class="keyword">from</span> gevent.local <span class="keyword">import</span> local</div><div class="line"></div><div class="line">stash = local()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></div><div class="line">    stash.x = <span class="number">1</span></div><div class="line">    print(stash.x)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">()</span>:</span></div><div class="line">    stash.y = <span class="number">2</span></div><div class="line">    print(stash.y)</div><div class="line"></div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        stash.x</div><div class="line">    <span class="keyword">except</span> AttributeError:</div><div class="line">        print(<span class="string">"x is not local to f2"</span>)</div><div class="line"></div><div class="line">g1 = gevent.spawn(f1)</div><div class="line">g2 = gevent.spawn(f2)</div><div class="line"></div><div class="line">gevent.joinall([g1, g2])</div></pre></td></tr></table></figure></p>
<p>执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1</div><div class="line">2</div><div class="line">x is not local to f2</div></pre></td></tr></table></figure></p>
<p>很多集成了gevent的web框架将HTTP会话对象以线程局部变量的方式存储在gevent内。 例如使用Werkzeug实用库和它的proxy对象，我们可以创建Flask风格的请求对象。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> gevent.local <span class="keyword">import</span> local</div><div class="line"><span class="keyword">from</span> werkzeug.local <span class="keyword">import</span> LocalProxy</div><div class="line"><span class="keyword">from</span> werkzeug.wrappers <span class="keyword">import</span> Request</div><div class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> contextmanager</div><div class="line"></div><div class="line"><span class="keyword">from</span> gevent.wsgi <span class="keyword">import</span> WSGIServer</div><div class="line"></div><div class="line">_requests = local()</div><div class="line">request = LocalProxy(<span class="keyword">lambda</span>: _requests.request)</div><div class="line"></div><div class="line"><span class="meta">@contextmanager</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sessionmanager</span><span class="params">(environ)</span>:</span></div><div class="line">    _requests.request = Request(environ)</div><div class="line">    <span class="keyword">yield</span></div><div class="line">    _requests.request = <span class="keyword">None</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">logic</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">"Hello "</span> + request.remote_addr</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">application</span><span class="params">(environ, start_response)</span>:</span></div><div class="line">    status = <span class="string">'200 OK'</span></div><div class="line"></div><div class="line">    <span class="keyword">with</span> sessionmanager(environ):</div><div class="line">        body = logic()</div><div class="line"></div><div class="line">    headers = [</div><div class="line">        (<span class="string">'Content-Type'</span>, <span class="string">'text/html'</span>)</div><div class="line">    ]</div><div class="line"></div><div class="line">    start_response(status, headers)</div><div class="line">    <span class="keyword">return</span> [body]</div><div class="line">	WSGIServer((<span class="string">''</span>, <span class="number">8000</span>), application).serve_forever()</div></pre></td></tr></table></figure></p>
<h4 id="子进程"><a href="#子进程" class="headerlink" title="子进程"></a>子进程</h4><p>从gevent 1.0起，支持gevent.subprocess，支持协作式的等待子进程。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> gevent</div><div class="line"><span class="keyword">from</span> gevent.subprocess <span class="keyword">import</span> Popen, PIPE</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">cron</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        print(<span class="string">"cron"</span>)</div><div class="line">        gevent.sleep(<span class="number">0.2</span>)</div><div class="line"></div><div class="line">g = gevent.spawn(cron)</div><div class="line">sub = Popen([<span class="string">'sleep 1; uname'</span>], stdout=PIPE, shell=<span class="keyword">True</span>)</div><div class="line">out, err = sub.communicate()</div><div class="line">g.kill()</div><div class="line">print(out.rstrip())</div><div class="line">``` </div><div class="line"> 执行结果：</div></pre></td></tr></table></figure></p>
<pre><code>cron
cron
cron
cron
cron
Linux
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">很多人也想将gevent和multiprocessing一起使用。最明显的挑战之一 就是multiprocessing提供的进程间通信默认不是协作式的。由于基于 multiprocessing.Connection的对象(例如Pipe)暴露了它们下面的 文件描述符(file descriptor)，gevent.socket.wait_read和wait_write 可以用来在直接读写之前协作式的等待ready-to-read/ready-to-write事件。</div><div class="line"></div><div class="line">```python</div><div class="line">import gevent</div><div class="line">from multiprocessing import Process, Pipe</div><div class="line">from gevent.socket import wait_read, wait_write</div><div class="line"></div><div class="line"># To Process</div><div class="line">a, b = Pipe()</div><div class="line"></div><div class="line"># From Process</div><div class="line">c, d = Pipe()</div><div class="line"></div><div class="line">def relay():</div><div class="line">    for i in xrange(5):</div><div class="line">        msg = b.recv()</div><div class="line">        c.send(msg + &quot; in &quot; + str(i))</div><div class="line"></div><div class="line">def put_msg():</div><div class="line">    for i in xrange(5):</div><div class="line">        wait_write(a.fileno())</div><div class="line">        a.send(&apos;hi&apos;)</div><div class="line"></div><div class="line">def get_msg():</div><div class="line">    for i in xrange(5):</div><div class="line">        wait_read(d.fileno())</div><div class="line">        print(d.recv())</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    proc = Process(target=relay)</div><div class="line">    proc.start()</div><div class="line"></div><div class="line">    g1 = gevent.spawn(get_msg)</div><div class="line">    g2 = gevent.spawn(put_msg)</div><div class="line">    gevent.joinall([g1, g2], timeout=1)</div><div class="line">```	  </div><div class="line">执行结果：</div><div class="line">```	</div><div class="line">hi in 0</div><div class="line">hi in 1</div><div class="line">hi in 2</div><div class="line">hi in 3</div><div class="line">hi in 4</div></pre></td></tr></table></figure>
<p>然而要注意，组合multiprocessing和gevent必定带来 依赖于操作系统(os-dependent)的缺陷，其中有：</p>
<p>在兼容POSIX的系统创建子进程(forking)之后， 在子进程的gevent的状态是不适定的(ill-posed)。一个副作用就是， multiprocessing.Process创建之前的greenlet创建动作，会在父进程和子进程两方都运行。</p>
<p>上例的put_msg()中的a.send()可能依然非协作式地阻塞调用的线程：一个 ready-to-write事件只保证写了一个byte。在尝试写完成之前底下的buffer可能是满的。</p>
<p>上面表示的基于wait_write()/wait_read()的方法在Windows上不工作 (IOError: 3 is not a socket (files are not supported))，因为Windows不能监视 pipe事件。</p>
<p>Python包gipc以大体上透明的方式在 兼容POSIX系统和Windows上克服了这些挑战。它提供了gevent感知的基于 multiprocessing.Process的子进程和gevent基于pipe的协作式进程间通信。</p>
<h4 id="Actors"><a href="#Actors" class="headerlink" title="Actors"></a>Actors</h4><p>actor模型是一个由于Erlang变得普及的更高层的并发模型。 简单的说它的主要思想就是许多个独立的Actor，每个Actor有一个可以从 其它Actor接收消息的收件箱。Actor内部的主循环遍历它收到的消息，并根据它期望的行为来采取行动。</p>
<p>Gevent没有原生的Actor类型，但在一个子类化的Greenlet内使用队列， 我们可以定义一个非常简单的。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> gevent</div><div class="line"><span class="keyword">from</span> gevent.queue <span class="keyword">import</span> Queue</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Actor</span><span class="params">(gevent.Greenlet)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.inbox = Queue()</div><div class="line">        Greenlet.__init__(self)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">receive</span><span class="params">(self, message)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        Define in your subclass.</div><div class="line">        """</div><div class="line">        <span class="keyword">raise</span> <span class="built_in">NotImplemented</span>()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_run</span><span class="params">(self)</span>:</span></div><div class="line">        self.running = <span class="keyword">True</span></div><div class="line"></div><div class="line">        <span class="keyword">while</span> self.running:</div><div class="line">            message = self.inbox.get()</div><div class="line">            self.receive(message)</div></pre></td></tr></table></figure></p>
<p>下面是一个使用的例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> gevent</div><div class="line"><span class="keyword">from</span> gevent.queue <span class="keyword">import</span> Queue</div><div class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> Greenlet</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pinger</span><span class="params">(Actor)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">receive</span><span class="params">(self, message)</span>:</span></div><div class="line">        print(message)</div><div class="line">        pong.inbox.put(<span class="string">'ping'</span>)</div><div class="line">        gevent.sleep(<span class="number">0</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ponger</span><span class="params">(Actor)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">receive</span><span class="params">(self, message)</span>:</span></div><div class="line">        print(message)</div><div class="line">        ping.inbox.put(<span class="string">'pong'</span>)</div><div class="line">        gevent.sleep(<span class="number">0</span>)</div><div class="line"></div><div class="line">ping = Pinger()</div><div class="line">pong = Ponger()</div><div class="line"></div><div class="line">ping.start()</div><div class="line">pong.start()</div><div class="line"></div><div class="line">ping.inbox.put(<span class="string">'start'</span>)</div><div class="line">gevent.joinall([ping, pong])</div></pre></td></tr></table></figure></p>
<h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><ul>
<li>Gevent ZeroMQ</li>
<li>简单server</li>
<li>WSGI Servers</li>
<li>流式server</li>
<li>Long Polling</li>
<li>Websockets</li>
</ul>
<h4 id="简单server"><a href="#简单server" class="headerlink" title="简单server"></a>简单server</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># On Unix: Access with ``$ nc 127.0.0.1 5000``</span></div><div class="line"><span class="comment"># On Window: Access with ``$ telnet 127.0.0.1 5000``</span></div><div class="line"></div><div class="line"><span class="keyword">from</span> gevent.server <span class="keyword">import</span> StreamServer</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle</span><span class="params">(socket, address)</span>:</span></div><div class="line">    socket.send(<span class="string">"Hello from a telnet!\n"</span>)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</div><div class="line">        socket.send(str(i) + <span class="string">'\n'</span>)</div><div class="line">    socket.close()</div><div class="line"></div><div class="line">server = StreamServer((<span class="string">'127.0.0.1'</span>, <span class="number">5000</span>), handle)</div><div class="line">server.serve_forever()</div></pre></td></tr></table></figure>
<h4 id="WSGI-Servers-And-Websockets"><a href="#WSGI-Servers-And-Websockets" class="headerlink" title="WSGI Servers And Websockets"></a>WSGI Servers And Websockets</h4><p>Gevent为HTTP内容服务提供了两种WSGI server。从今以后就称为 wsgi和pywsgi：</p>
<ul>
<li>gevent.wsgi.WSGIServer</li>
<li>gevent.pywsgi.WSGIServer</li>
</ul>
<p>glb中使用<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> click</div><div class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</div><div class="line"><span class="keyword">from</span> gevent.pywsgi <span class="keyword">import</span> WSGIServer</div><div class="line"><span class="keyword">from</span> geventwebsocket.handler <span class="keyword">import</span> WebSocketHandler</div><div class="line"></div><div class="line"><span class="keyword">import</span> v1</div><div class="line"><span class="keyword">from</span> .settings <span class="keyword">import</span> Config</div><div class="line"><span class="keyword">from</span> .sockethandler <span class="keyword">import</span> handle_websocket</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_app</span><span class="params">(config=None)</span>:</span></div><div class="line">    app = Flask(__name__, static_folder=<span class="string">'static'</span>)</div><div class="line">    <span class="keyword">if</span> config:</div><div class="line">        app.config.update(config)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        app.config.from_object(Config)</div><div class="line"></div><div class="line">    app.register_blueprint(</div><div class="line">        v1.bp,</div><div class="line">        url_prefix=<span class="string">'/v1'</span>)</div><div class="line">    <span class="keyword">return</span> app</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">wsgi_app</span><span class="params">(environ, start_response)</span>:</span></div><div class="line">    path = environ[<span class="string">'PATH_INFO'</span>]</div><div class="line">    <span class="keyword">if</span> path == <span class="string">'/websocket'</span>:</div><div class="line">        handle_websocket(environ[<span class="string">'wsgi.websocket'</span>])</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">return</span> create_app()(environ, start_response)</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">@click.command()</span></div><div class="line"><span class="meta">@click.option('-h', '--host_port', type=(unicode, int),</span></div><div class="line">    default=(<span class="string">'0.0.0.0'</span>, <span class="number">5000</span>), help=<span class="string">'Host and port of server.'</span>)</div><div class="line"><span class="meta">@click.option('-r', '--redis', type=(unicode, int, int),</span></div><div class="line">    default=(<span class="string">'127.0.0.1'</span>, <span class="number">6379</span>, <span class="number">0</span>),</div><div class="line">    help=<span class="string">'Redis url of server.'</span>)</div><div class="line"><span class="meta">@click.option('-p', '--port_range', type=(int, int),</span></div><div class="line">    default=(<span class="number">50000</span>, <span class="number">61000</span>),</div><div class="line">    help=<span class="string">'Port range to be assigned.'</span>)</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">manage</span><span class="params">(host_port, redis=None, port_range=None)</span>:</span></div><div class="line">    Config.REDIS_URL = <span class="string">'redis://%s:%s/%s'</span> % redis</div><div class="line">    Config.PORT_RANGE = port_range</div><div class="line">    http_server = WSGIServer(host_port,</div><div class="line">                             wsgi_app, handler_class=WebSocketHandler)</div><div class="line">    <span class="keyword">print</span> <span class="string">'----GLB Server run at %s:%s-----'</span> % host_port</div><div class="line">    <span class="keyword">print</span> <span class="string">'----Redis Server run at %s:%s:%s-----'</span> % redis</div><div class="line">    http_server.serve_forever()</div></pre></td></tr></table></figure></p>
<h2 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h2><p>和其他异步I/O框架一样,gevent也有一些缺陷:</p>
<ul>
<li>阻塞(真正的阻塞,在内核级别)在程序中的某个地方停止了所有的东西.这很像C代码中monkey patch没有生效</li>
<li>保持CPU处于繁忙状态.greenlet不是抢占式的,这可能导致其他greenlet不会被调度.</li>
<li>在greenlet之间存在死锁的可能.</li>
</ul>
<p>一个gevent回避的缺陷是,你几乎不会碰到一个和异步无关的Python库–它将阻塞你的应用程序,因为纯Python库使用的是monkey patch的stdlib.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前述&quot;&gt;&lt;a href=&quot;#前述&quot; class=&quot;headerlink&quot; title=&quot;前述&quot;&gt;&lt;/a&gt;前述&lt;/h2&gt;&lt;h3 id=&quot;进程-线程-协程-异步&quot;&gt;&lt;a href=&quot;#进程-线程-协程-异步&quot; class=&quot;headerlink&quot; title=&quot;进程 线程 协程 异步&quot;&gt;&lt;/a&gt;进程 线程 协程 异步&lt;/h3&gt;&lt;p&gt;并发编程（不是并行）目前有四种方式：多进程、多线程、协程和异步。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多进程编程在python中有类似C的os.fork,更高层封装的有multiprocessing标准库&lt;/li&gt;
&lt;li&gt;多线程编程python中有Thread和threading&lt;/li&gt;
&lt;li&gt;异步编程在linux下主+要有三种实现select，poll，epoll&lt;/li&gt;
&lt;li&gt;协程在python中通常会说到yield，关于协程的库主要有greenlet,stackless,gevent,eventlet等实现。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="技术" scheme="https://softlns.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="python" scheme="https://softlns.github.io/tags/python/"/>
    
      <category term="Gevent" scheme="https://softlns.github.io/tags/Gevent/"/>
    
      <category term="协程" scheme="https://softlns.github.io/tags/%E5%8D%8F%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu--&amp;quot;unmount:command not found&amp;quot;的解决方法</title>
    <link href="https://softlns.github.io/2014/10/26/unmount-not-found/"/>
    <id>https://softlns.github.io/2014/10/26/unmount-not-found/</id>
    <published>2014-10-26T09:22:02.000Z</published>
    <updated>2016-12-05T09:41:49.389Z</updated>
    
    <content type="html"><![CDATA[<p>不得不说，这是个很弱的问题，今儿碰巧遇到。答案也非常简单。虽然没什么营养，但是为了加深印象，也为了碰到这个问题的其他人搜索起来不要那么“举目无亲”，还是记录下来。</p>
<blockquote>
<p>根本没有什么unmount，而是umount。</p>
</blockquote>
<a id="more"></a>
<p>错误命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo unmount /dev/sda3</div></pre></td></tr></table></figure></p>
<p>正确命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo umount /dev/sda3</div></pre></td></tr></table></figure></p>
<p>注：如果一定要使用unmount，可以设置别名<code>alias unmount=&#39;umount&#39;</code> </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不得不说，这是个很弱的问题，今儿碰巧遇到。答案也非常简单。虽然没什么营养，但是为了加深印象，也为了碰到这个问题的其他人搜索起来不要那么“举目无亲”，还是记录下来。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;根本没有什么unmount，而是umount。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="技术" scheme="https://softlns.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="linux" scheme="https://softlns.github.io/tags/linux/"/>
    
      <category term="ubuntu" scheme="https://softlns.github.io/tags/ubuntu/"/>
    
      <category term="shell" scheme="https://softlns.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Go语言--并发篇</title>
    <link href="https://softlns.github.io/2014/09/13/go-goroutine/"/>
    <id>https://softlns.github.io/2014/09/13/go-goroutine/</id>
    <published>2014-09-13T08:54:45.000Z</published>
    <updated>2016-12-05T09:02:10.278Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p><b>Go中并发程序依靠是：goroutine和channel</b></p>
</blockquote>
<h3 id="什么是goroutine？"><a href="#什么是goroutine？" class="headerlink" title="什么是goroutine？"></a>什么是goroutine？</h3><p>Goroutine，被普遍认为是协程的go语言实现。《Go语言编程》中说goroutine是轻量级线程(即协程coroutine, 原书90页). 在第九章进阶话题中, 作者又一次提到, “从根本上来说, goroutine就是一种go语言版本的协程(coroutine)” (原书204页). 但作者Rob Pike并不这么说。</p>
<p><b>“一个Goroutine是一个与其他goroutines并发运行在同一地址空间的Go函数或方法。一个运行的程序由一个或更多个goroutine组成。它与线程、协程、进程等不同。它是一个goroutine。”</b></p>
<a id="more"></a>
<h4 id="1-goroutine-vs-协程"><a href="#1-goroutine-vs-协程" class="headerlink" title="1. goroutine vs 协程"></a>1. goroutine vs 协程</h4><p>是go语言原生支持的，相对于一般由库实现协程的方式，goroutine更加强大，它的调度一定程度上是由go运行时（runtime）管理。其好处之一是，当某goroutine发生阻塞时（例如同步IO操作等），会自动出让CPU给其它goroutine。</p>
<h4 id="2-goroutine-vs-线程"><a href="#2-goroutine-vs-线程" class="headerlink" title="2. goroutine vs 线程"></a>2. goroutine vs 线程</h4><p>一个goroutine并不相当于一个线程，goroutine的出现正是为了替代原来的线程概念成为最小的调度范围，一旦运行goroutine时，先去当前线程查找，如果线程阻塞了，则被分配到空闲的线程，如果没有空闲的线程，那么就会新建一个线程。注意的是，当goroutine执行完毕后，线程不会回收退出，而是成为了空闲的线程。</p>
<h3 id="goroutine的使用"><a href="#goroutine的使用" class="headerlink" title="goroutine的使用"></a>goroutine的使用</h3><pre><code>package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func ready(w string, sec int64) {
    time.Sleep(sec * 1e9)
    fmt.Println(w, &quot;is ready!&quot;)
}

func main() {
    go ready(&quot;Tee&quot;, 2)
    go ready(&quot;Coffee&quot;, 1)
    fmt.Println(&quot;I&apos;m waiting&quot;)
    time.Sleep(5 * 1e9)
}
</code></pre><p>主线程为什么要sleep？</p>
<h3 id="channel的使用"><a href="#channel的使用" class="headerlink" title="channel的使用"></a>channel的使用</h3><p>channel是线程之间通信的管道</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

var c chan int

func ready(w string, sec int) {
    time.Sleep(int64(sec) * 1e9)
    fmt.Println(w, &quot;is ready!&quot;)
    c &lt;- 1
}

func main() {
    c = make(chan int)
    go ready(&quot;Tee&quot;, 2)
    go ready(&quot;Coffee&quot;, 1)
    fmt.Println(&quot;I&apos;m waiting, but not too long&quot;)
    &lt;-c
    &lt;-c
</code></pre><h4 id="channel-进一步理解"><a href="#channel-进一步理解" class="headerlink" title="channel 进一步理解"></a>channel 进一步理解</h4><p>channel分为两种：有buffer的，没有buffer的  默认的是没有buffer的</p>
<p>c1 := make(chan int)<br>c2 := make(chan int, 0)<br>c3 := make(chan int, 100)</p>
<p>有缓冲的channel，注意先“放”后“取”<br>没有缓冲的channel，注意先“取”后“放”</p>
<h3 id="图解并行编程"><a href="#图解并行编程" class="headerlink" title="图解并行编程"></a>图解并行编程</h3><h4 id="1-单个channel，单个goroutine-一个写，一个读"><a href="#1-单个channel，单个goroutine-一个写，一个读" class="headerlink" title="1. 单个channel，单个goroutine,  一个写，一个读"></a>1. 单个channel，单个goroutine,  一个写，一个读</h4><pre><code>package main

func main() {
    ch := make(chan int)

    go func() {
        ch &lt;- 42
    }()

    &lt;-ch
} 
</code></pre><p><img src="https://divan.github.io/demos/gifs/hello.gif" alt="hello"></p>
<h4 id="2-加入定时器的实现"><a href="#2-加入定时器的实现" class="headerlink" title="2. 加入定时器的实现"></a>2. 加入定时器的实现</h4><pre><code>package main

import &quot;time&quot;

func timer(d time.Duration) &lt;-chan int {
    c := make(chan int)
    go func() {
        time.Sleep(d)
        c &lt;- 1 
    }()
    return c 
}

func main() {
    for i :=0; i &lt; 24; i++ {
        c := timer(i * time.Second)
        &lt;-c
    }
}
</code></pre><p><img src="https://divan.github.io/demos/gifs/timers.gif" alt="timers"></p>
<h4 id="3-乒乓模式"><a href="#3-乒乓模式" class="headerlink" title="3.乒乓模式"></a>3.乒乓模式</h4><pre><code>import main

import &quot;time&quot;

func main() {
    var Ball int
    table := make(chan int)
    go player(table)
    go player(table)

    table &lt;- Ball
    time.Sleep(1 * time.Second)
    &lt;-table
}

func player(table chan int) {
    for {
        ball := &lt;-table
        ball++
        time.Sleep(100 * time.Millisecond)
        table &lt;- ball
    }
}
</code></pre><p><img src="https://divan.github.io/demos/gifs/pingpong.gif" alt="pingpong"></p>
<p>如果有3个人</p>
<pre><code>go player(table)
go player(table)
go player(table)
</code></pre><p><img src="https://divan.github.io/demos/gifs/pingpong3.gif" alt="pingpong3"></p>
<p>如果有100个人</p>
<pre><code>for i := 0: i&lt; 100; i++ {
    go player(table)
}
</code></pre><p><img src="https://divan.github.io/demos/gifs/pingpong100.gif" alt="pingpong100"></p>
<p>goroutines从某个特定的channel接收数据遵循<a href="https://github.com/golang/go/blob/master/src/runtime/chan.go#L34" target="_blank" rel="external">FIFO order</a></p>
<h4 id="4-Fan-In（扇入）"><a href="#4-Fan-In（扇入）" class="headerlink" title="4.Fan-In（扇入）"></a>4.Fan-In（扇入）</h4><p>并发世界的一个流行的编程模式————扇入模式。（相反是扇出模式）<br>扇入是一个函数读取多个输入和多路复用到单通道。</p>
<p>note：在软件工程中，模块的扇入是指有多少个上级模块调用它。扇入越大，表示该模块被更多的上级模块共享。这当然是我们所希望的。但是不能为了获得高扇入而不惜代价，例如把彼此无关的功能凑在一起构成一个模块，虽然扇入数高了，但这样的模块内聚程度必然低。这是我们应避免的。</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func producer(ch chan int, d time.Duration) {
    var i int
    for {
        ch &lt;- i
        i++
        time.Sleep(d)
    }
}

func reader(out chan int) {
    for x := range out {
        fmt.Println(x)
    }
}

func main() {
    ch := make(chan int)
    out := make(chan int)
    go producer(ch, 100*time.Millisecond)
    go producer(ch, 100*time.Millisecond)
    go reader(out)
    for i := range ch {
        out &lt;- i
    } 
}
</code></pre><p><img src="https://divan.github.io/demos/gifs/fanin.gif" alt="fanin"></p>
<h4 id="5-Workers模式-fan-out-扇出"><a href="#5-Workers模式-fan-out-扇出" class="headerlink" title="5. Workers模式(fan-out) 扇出"></a>5. Workers模式(fan-out) 扇出</h4><p>与扇入相反，多个函数从单一通道读取任务，分发任务到各个cpu核心上。</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;sync&quot;
    &quot;time&quot;
)

func worker(taskCh &lt;-chan int, wg *sync.WaitGroup) {
    defer wg.Done()
    for {
        task, ok := &lt;-taskCh
        if !ok {
            return 
        }
        d := time.Duration(task) * time.Millisecond
        time.Sleep(d)
        fmt.Println(&quot;processing task&quot;, task)
    }
}

func pool(wg *sync.WaitGroup, workers, tasks int) {
    tasksCh := make(chan int)

    for i := 0; i &lt; workers; i++ {
        go worker(taskCh, wg)
    }

    for i := 0; i &lt; tasks; i++ {
        taskCh &lt;- i
    }

    close(tasksCh)
}

func main() {
    var wg sync.WaitGroup
    wg.add(36)
    go poll(&amp;wg, 36, 50)
    wg.Wait()
}
</code></pre><p><img src="https://divan.github.io/demos/gifs/workers.gif" alt="workers"></p>
<p>更复杂的例子：</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;sync&quot;
    &quot;time&quot;
)

const (
    WORKERS     = 5
    SUBWORKERS  = 3
    TASKS       = 20
    SUBTASKS    = 10
)

func subworker(subtasks chan int) {
    for {
        task, ok := &lt;-subtasks
        if !ok {
            return
        }
        time.Sleep(time.Duration(task) * time.Millisecond)
        fmt.Println(task)
    }
}

func worker(tasks &lt;-chan int, wg *sync.WaitGroup) {
    defer wg.Done()
    for {
        task, ok := &lt;-tasks
        if !ok {
            return
        }

        subtasks := make(chan int)
        for i := 0; i &lt; SUBWORKERS; i++ {
            go subworker(subtasks)
        }
        for i := 0; i &lt; SUBTASKS; i++ {
            task1 := task * i
            subtasks &lt;- task1
        }
        close(subtasks)
    }
}

func main() {
    var wg sync.WaitGroup
    wg.Add(WORKERS)
    tasks := make(chan int)

    for i := 0; i &lt; WORKERS; i++ {
        go worker(tasks, &amp;wg)
    }

    for i := 0; i &lt; TASKS; i++ {
        tasks &lt;- i
    }

    close(tasks)
    wg.Wait()
}
</code></pre><p><img src="https://divan.github.io/demos/gifs/workers2.gif" alt="enter description here"></p>
<h4 id="servers模式-和扇出相类似"><a href="#servers模式-和扇出相类似" class="headerlink" title="servers模式 (和扇出相类似)"></a>servers模式 (和扇出相类似)</h4><pre><code>package main

import &quot;net&quot;

func handler(c net.Conn) {
    c.Write([] byte(&quot;ok&quot;))
    c.Close()
}

func main() {
    l, err := net.Listen(&quot;tcp&quot;, &quot;:5000&quot;)
    if err != nil {
        panic(err)
    }
    for {
        c, err := l.Accept()
        if err != nil {
            continue
        }
        go handler(c)
    }
}
</code></pre><p><img src="https://divan.github.io/demos/gifs/servers.gif" alt="servers"></p>
<p><a href="https://www.youtube.com/watch?v=rFejpH_tAHM" target="_blank" rel="external">Simplicity is complicated</a></p>
<h4 id="server模式2（logger）"><a href="#server模式2（logger）" class="headerlink" title="server模式2（logger）"></a>server模式2（logger）</h4><pre><code>package main

import (
    &quot;fmt&quot;
    &quot;net&quot;
    &quot;time&quot;
)

func handler(c net.Conn, ch chan string) {
    ch &lt;- c.RemoteAddr().String()
    c.Write([]byte(&quot;ok&quot;))
    c.Close()
}

func logger(ch chan string) {
    for {
        fmt.Println(&lt;-ch)
    }
}

func server(l net.Listener, ch chan string) {
    for {
        c, err := l.Accept()
        if err != nil {
            continue
        }
        go handler(c, ch)
    }
}

func main() {
    l, err := net.Listen(&quot;tcp&quot;, &quot;:5000&quot;)
    if err != nil {
        paic(err)
    }
    ch := make(chan string)
    go logger(ch)
    go server(l, ch)
    time.Sleep(10 * time.Second)
}
</code></pre><p><img src="https://divan.github.io/demos/gifs/servers2.gif" alt="enter description here"></p>
<h4 id="Server-Worker-模式"><a href="#Server-Worker-模式" class="headerlink" title="Server + Worker 模式"></a>Server + Worker 模式</h4><pre><code>package main

import (
    &quot;net&quot;
    &quot;time&quot;
)

func handler(c net.Conn, ch chan string) {
    addr := c.RemoteAddr().String()
    ch &lt;- addr
    time.Sleep(100 * time.Millisecond)
    c.Write([]byte(&quot;ok&quot;))
    c.Close()
}

func logger(wch chan int, results chan int) {
    for {
        data := &lt;-wch
        data++
        result &lt;- data
    }
}

func parse(results chan int) {
    for {
        &lt;-results
    }
}

func pool(ch chan string, n int) {
    wch := make(chan int)
    results := make(chan int)
    for i := 0; i &lt; n; i++ {
        go logger(wch, results)
    }
    go parse(results)
    for {
        addr := &lt;-ch 
        l := len(addr)
        wch &lt;- l
    }
}

func server(l net.Listener, ch chan string) {
    for {
        c, err := l.Accept()
        if err != nil {
            continue
        }
        go handler(c, ch)
    }
}

func main() {
    l, err := net.Listen(&quot;tcp&quot;, &quot;:5000&quot;)
    if err != nil {
        panic(err)
    }
    ch := make(chan string)
    go pool(ch, 4)
    go server(l, ch)
    time.Sleep(10 * time.Second)
}
</code></pre><p><img src="https://divan.github.io/demos/gifs/servers3.gif" alt="servers3"></p>
<h3 id="Concurrent-Prime-Sieve-素数帅选器"><a href="#Concurrent-Prime-Sieve-素数帅选器" class="headerlink" title="Concurrent Prime Sieve(素数帅选器)"></a>Concurrent Prime Sieve(素数帅选器)</h3><pre><code>package main

import &quot;fmt&quot;

func Generate(ch chan&lt;- int) {
    for i := 2; ; i++ {
        ch &lt;- i
    }
}

func Filter(in &lt;-chan int, out chan&lt;- int, prime int) {
    for {
        i := &lt;-in
        if i % prime != 0 {
            out &lt;- i
        }
    }
}

func main() {
    ch := make(chan int)
    go Generate(ch)
    for i := 0; i &lt; 10; i++ {
        prime := &lt;-ch
        fmt.Println(prime)
        ch1 := make(chan int)
        go Filter(ch, ch1, prime)
        ch = ch1
    }
}
</code></pre><p><img src="https://divan.github.io/demos/gifs/primesieve.gif" alt="prime sieve"></p>
<h3 id="Parallelism-is-not-Concurrency"><a href="#Parallelism-is-not-Concurrency" class="headerlink" title="Parallelism is not Concurrency"></a>Parallelism is not Concurrency</h3><p>简而言之:<br><b></b></p>
<blockquote>
<p>Parallelism is simply running things in parallel.<br>Concurrency is a way to structure your program.<br></p>
</blockquote>
<p>一图胜千言</p>
<h4 id="parallelism-并行"><a href="#parallelism-并行" class="headerlink" title="parallelism 并行"></a>parallelism 并行</h4><p><img src="https://divan.github.io/demos/gifs/parallelism1.gif" alt="parallelism1"></p>
<p><img src="https://divan.github.io/demos/gifs/parallelism2.gif" alt="parallelism2"></p>
<h4 id="concurrency-并发"><a href="#concurrency-并发" class="headerlink" title="concurrency 并发"></a>concurrency 并发</h4><p><img src="https://divan.github.io/demos/gifs/primesieve.gif" alt="concurrency1"></p>
<p><img src="https://divan.github.io/demos/gifs/workers2.gif" alt="concurrency2"></p>
<p><img src="https://divan.github.io/demos/gifs/pingpong100.gif" alt="concurrency3"></p>
<p>Rob Pike-<a href="https://www.youtube.com/watch?v=cN_DpYBzKso" target="_blank" rel="external">Concurrency Is Not Parallelism</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;b&gt;Go中并发程序依靠是：goroutine和channel&lt;/b&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;什么是goroutine？&quot;&gt;&lt;a href=&quot;#什么是goroutine？&quot; class=&quot;headerlink&quot; title=&quot;什么是goroutine？&quot;&gt;&lt;/a&gt;什么是goroutine？&lt;/h3&gt;&lt;p&gt;Goroutine，被普遍认为是协程的go语言实现。《Go语言编程》中说goroutine是轻量级线程(即协程coroutine, 原书90页). 在第九章进阶话题中, 作者又一次提到, “从根本上来说, goroutine就是一种go语言版本的协程(coroutine)” (原书204页). 但作者Rob Pike并不这么说。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;“一个Goroutine是一个与其他goroutines并发运行在同一地址空间的Go函数或方法。一个运行的程序由一个或更多个goroutine组成。它与线程、协程、进程等不同。它是一个goroutine。”&lt;/b&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="golang" scheme="https://softlns.github.io/tags/golang/"/>
    
      <category term="goroutine" scheme="https://softlns.github.io/tags/goroutine/"/>
    
      <category term="channel" scheme="https://softlns.github.io/tags/channel/"/>
    
  </entry>
  
</feed>
